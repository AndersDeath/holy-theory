<h1>Some Awesome Header</h1><ul><li><h1></h1><hr/><span><h1 id="binary-search">Binary search</h1>
<p><img src="./binary-search.png" alt="Binary search"></p>
<p>Steps:</p>
<p>Step 1 - Read the search element from the user.
Step 2 - Find the middle element in the sorted list.
Step 3 - Compare the search element with the middle element in the sorted list.
Step 4 - If both are matched, then display &quot;Given element is found!!!&quot; and terminate the function.
Step 5 - If both are not matched, then check whether the search element is smaller or larger than the middle element.
Step 6 - If the search element is smaller than middle element, repeat steps 2, 3, 4 and 5 for the left sublist of the middle element.
Step 7 - If the search element is larger than middle element, repeat steps 2, 3, 4 and 5 for the right sublist of the middle element.
Step 8 - Repeat the same process until we find the search element in the list or until sublist contains only one element.
Step 9 - If that element also doesn&#39;t match with the search element, then returns -1;</p>
<p>Time Complexity:</p>
<p>Worst case: O(log n)
Average case: O(log n)
Best case: O(1)</p>
<pre><code class="language-typescript">
function binarySearch(nums: number[], target: number): number {
  let left: number = 0;
  let right: number = nums.length - 1;

  while (left &lt;= right) {
    const mid: number = Math.floor((left + right) / 2);

    if (nums[mid] === target) return mid;
    if (target &lt; nums[mid]) right = mid - 1;
    else left = mid + 1;
  }

  return -1;
}
</code></pre>
<pre><code class="language-java">
class Solution {
    private static int binarySearch(int[] array, int target) {
        
        int low = 0;
        int high = array.length - 1;
        
        while(low &lt;= high) {
            int middle = low + (high - low) / 2;
            int value = array[middle];
            
            if(value &lt; target) {
                low = middle + 1;
            } else if(value &gt; target) {
                high = middle - 1;
                
            } else {
                return middle;
            }
        }
        return -1;
    }
}
</code></pre>
<pre><code class="language-python">#binary search

def binary_search(list, item):
    low = 0
    high = len(list) - 1
    while low &lt;= high:
        mid = (low+high)/2
        guess = list[mid]
        if guess == item:
            return mid
        if guess &gt; item:
            high = mid - 1
        else:
            low = mid +1
    return None

my_list = [1, 3, 5, 7, 9]

res = binary_search(my_list, 3)

print(my_list[res])
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="binary-tree-in-order-traversal">Binary tree in order traversal</h1>
<pre><code class="language-java">class Solution {
    
    
    List&lt;Integer&gt; getInOrderTraversal(Node root) {
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
        Node node = root;
        
        while(node != null || !stack.isEmpty()) {
            while(node != null) {
                stack.push(node);
                node = node.left;
            }
            list.add(stack.peek().data);
            node = stack.pop().right;
        }
        
        return list;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="binary-tree-postorder-traversal">Binary tree postorder traversal</h1>
<pre><code class="language-java">class Solution {
    
    void utility(Node root, List&lt;Integer&gt; traversal) {
        if(root == null) {
            return;
        }
        
        utility(root.left, traversal);
        utility(root.right, traversal);
        traversal.add(root.data);

    }
    
    List&lt;Integer&gt; getPostorderTraversal(Node root) {
        List&lt;Integer&gt; traversal = new ArrayList&lt;Integer&gt;();
        utility(root, traversal);
        return traversal;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="binary-tree-preorder-traversal">Binary tree preorder traversal</h1>
<pre><code class="language-java">class Solution {
    
    void utility(Node root, List&lt;Integer&gt; traversal) {
        if(root == null) {
            return;
        }
        
        traversal.add(root.data);
        utility(root.left, traversal);
        utility(root.right, traversal);
    }
    
    List&lt;Integer&gt; getPreorderTraversal(Node root) {
        List&lt;Integer&gt; traversal = new ArrayList&lt;Integer&gt;();
        utility(root, traversal);
        return traversal;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="bubble-sort">Bubble sort</h1>
<pre><code class="language-typescript">function bubbleSort(array: number[] | string[]) {
    for (let i = 0; i &lt; array.length; i++) {
        for (let j = 0; j &lt; array.length - 1 - i; j++) {
            if (array[j] &gt; array[j + 1]) {
                [array[j], array[j + 1]] = [array[j + 1], array[j]];
            }
        }
    }
    return array;
}

console.log(bubbleSort([2,5,2,6,7,2,22,5,7,9,0,2,3]))
</code></pre>
<pre><code class="language-java">    public static void bubbleSort(int[] array) {
        for(int i = 0; i &lt; array.length - 1; i++) {
            for(int j = 0; j &lt; array.length - i - 1; j++) {
                if(array[j] &gt; array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="diffie-hellman-algorithm">Diffie hellman algorithm</h1>
<pre><code class="language-javascript">function power(a: any, b: any, p: any) {
    if(b === 1) {
        return 1
    } else {
        return Math.pow(a,b) % p
    }
}


function DiffieHellman() {

    let P, G, x, a, y, b, ka, kb;

    P = 23

    console.log(&quot;The value of P :&quot;, P);

    G = 9;

    console.log(&quot;The value of G :&quot;, G);

    a = 4;

    console.log(&quot;The private key a for Alice : &quot;, a);

    x = power(G,a,P);

    b = 3;

    console.log(&quot;The private key a for Bob : &quot;, b);

    y = power(G,b,P);


    ka = power(y, a, P);
    kb = power(x, b, P);

    console.log(&quot;Secret key for the Alice is : &quot;, ka);
    console.log(&quot;Secret key for the Bob is : &quot;, kb);
}


DiffieHellman()
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="graph-adjacency-list">Graph adjacency list</h1>
<pre><code class="language-java">
public class GraphList {
    
    ArrayList&lt;LinkedList&lt;Node&gt;&gt; alist;

    
    GraphList() {
        alist = new ArrayList&lt;&gt;();
    }
    
    public void addNode(Node node) {
        LinkedList&lt;Node&gt; currentList = new LinkedList&lt;&gt;();
        currentList.add(node);
        alist.add(currentList);
    }
    
    public void addEdge(int src, int dst) {
        LinkedList&lt;Node&gt; currentList = alist.get(src);
        Node dstNode = alist.get(dst).get(0);
        currentList.add(dstNode);
        
    }
    public boolean checkEdge(int src, int dst) {
        LinkedList&lt;Node&gt; currentList = alist.get(src);
        Node dstNode = alist.get(dst).get(0);
        
        for(Node node: currentList) {
            if(node == dstNode) {
                return true;
            }
        }
        return false;
        
    }
    
    public void print() {
        for(LinkedList&lt;Node&gt; currentList : alist) {
            for(Node node: currentList) {
                System.out.print(node.data + &quot; -&gt; &quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="graph-adjacency-matrix">Graph adjacency matrix</h1>
<pre><code class="language-java">public class Graph {
    ArrayList&lt;Node&gt; nodes; 
    int[][] matrix;
    
    Graph(int size) {
        nodes = new ArrayList&lt;&gt;();
        matrix = new int[size][size];
    }
    
    public void addNode(Node node) {
        nodes.add(node);
    }
    
    public void addEdge(int src, int dst) {
        matrix[src][dst] = 1;
    }
    
    public boolean checkEdge(int src, int dst) {
        if(matrix[src][dst] == 1) {
            return true;
        } else {
            return false;
        }
    }
    
    public void print() {
        System.out.print(&quot;  &quot;); 
        for(Node node : nodes) {
            System.out.print(node.data + &quot; &quot;); 
        }
        System.out.println();
        
        for(int i = 0; i &lt; matrix.length; i++) {
            System.out.print(nodes.get(i).data + &quot; &quot;);
            for(int j =0; j &lt; matrix[i].length; j++) {
                System.out.print(matrix[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="insertion-sort">Insertion sort</h1>
<h2 id="typescript">TypeScript</h2>
<pre><code class="language-typescript">function insertionSort(array: number[] | string[]) {
    for (let i = 1; i &lt; array.length; i++) {
        let curr = array[i];
        let j = i - 1;
        for (j; j &gt;= 0 &amp;&amp; array[j] &gt; curr; j--) {
            array[j + 1] = array[j];
        }
        array[j + 1] = curr;
    }
    return array;
}

console.log(insertionSort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]));
</code></pre>
<h2 id="java">Java</h2>
<pre><code class="language-java">    class Solution {
        void insertionSort (int[] arr) {
            int n = arr.length;
            for(int i = 1; i &lt; n; i++) {
                int current = arr[i];
                int position = i - 1;
                while(position &gt;= 0 &amp;&amp; arr[position] &gt; current) {
                    arr[position + 1] = arr[position];
                    position--;
                }
                arr[position + 1] = current;
            }
        }
    }
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="interpolation-search">Interpolation search</h1>
<pre><code class="language-java">class Solution {
        
    private static int interpolationSearch(int[] array, int value) {
        int low = 0;
        int high = array.length - 1;
        
        while(value &gt;=array[low] &amp;&amp; value &lt;= array[high] &amp;&amp; low &lt;= high) {
            int probe = low + (high - low) * (value - array[low]) / (array[high] - array[low]);
            if(array[probe] == value) {
                return probe;
            } else if(array[probe] &gt; value) {
                low = probe + 1;
            } else {
                high = probe -1;
            }
            
        }
        
        return -1;
    }

}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="merge-sort">Merge sort</h1>
<h2 id="java">Java</h2>
<pre><code class="language-java">class Solution {
    
    void merge(int[] arr, int low, int mid, int high) {
        int subArr1Size = mid - low + 1;
        int subArr2Size = high - mid;
        
        int [] subArr1 = new int[subArr1Size];
        int [] subArr2 = new int[subArr2Size];
        
        for (int i = 0; i &lt; subArr1Size; i++) {
           subArr1[i] = arr[low + i];
           }
           for (int i = 0; i &lt; subArr2Size; i++) {
           subArr2[i] = arr[mid + 1 + i];	
        }
        int i = 0, j = 0, k = low;
        
        while(i &lt; subArr1Size &amp;&amp; j &lt; subArr2Size) {
            if(subArr1[i] &lt;= subArr2[j]) {
                arr[k] = subArr1[i];
                i++;
            } else {
                arr[k] = subArr2[j];
                j++;
            }
            k++;
        }
        while(i &lt; subArr1Size) {
            arr[k++] = subArr1[i++];
        }
        while (j &lt; subArr2Size) {
           arr[k++] = subArr2[j++];
       }
    }
    
    void mergesort(int[] arr, int low, int high){
        if(high &gt; low) {
            int mid = (high + low) / 2;
            mergesort(arr, low, mid);
            mergesort(arr, mid + 1, high);
            merge(arr, low, mid, high);
        }	
    }
    
    void mergeSort (int[] arr) {
        int n = arr.length;
        mergesort(arr, 0, n - 1);
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="quicksort">Quicksort</h1>
<pre><code class="language-java">class Solution {
    
    int makePartition(int [] arr, int low, int high) {
        int pivot = arr[high];
        int currentIndex = low - 1;
        for(int i = low; i &lt; high; i++) {
            if(arr[i] &lt; pivot) {
                currentIndex++;
                int temp = arr[i];
                arr[i] = arr[currentIndex];
                arr[currentIndex] = temp;
            }
            
        }
        int temp = arr[high];
        arr[high] = arr[currentIndex + 1];
        arr[currentIndex + 1] = temp;
        return currentIndex + 1;
    }
    
    void quicksort(int[] arr, int low, int high) {
        if(low &lt; high) {
            int pivot = makePartition(arr, low, high);
            quicksort(arr, low, pivot - 1);
            quicksort(arr, pivot + 1, high);
        }
    }
    
    void quickSort (int[] arr) {
        int n = arr.length;
        quicksort(arr, 0, n - 1);
    }
}
</code></pre>
<pre><code class="language-python">def quicksort(arr):
    if len(arr) &lt; 2:
        return arr
    else:
        pivot = arr[len(arr)/2]
        less = [i for i in arr[1:] if i &lt;= pivot]
        greater = [i for i in arr[1:] if i &gt; pivot]
        return quicksort(less) + [pivot] + quicksort(greater)

print(quicksort([10,2,3,1,5,4]))
</code></pre>
<pre><code class="language-java">class Solution {
    static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    private static void quickSort(int[] array, int start, int end) {
        if(end &lt;= start) return; // base case
        
        int pivot = partition(array, start, end);
        
        quickSort(array, start, pivot -1);
        quickSort(array, pivot + 1, end);
    }

    private static int partition(int[] array, int start, int end) {
        int pivot = array[end];
        
        int i = start - 1;
        
        for(int j = start; j &lt;= end -1; j++) {
            if(array[j] &lt; pivot) {
                i++;
                swap(array, i, j);
            }
        }
        i++;
        swap(array, i, end);
        
        return i;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="selection-sort">Selection sort</h1>
<p><img src="./selection-sort.png" alt="Selection sort"></p>
<pre><code class="language-typescript">function selectionSort(array: any[]) {
  for (let i = 0; i &lt; array.length - 1; i++) {
    let min = i;
    for (let j = i + 1; j &lt; array.length; j++) {
      if (array[min] &gt; array[j]) min = j;
    }
    [array[i], array[min]] =[array[min], array[i]]
  }
  return array;
}

console.log(selectionSort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]));
</code></pre>
<pre><code class="language-java">    public static void selectionSort(int[] array) {
        for(int i = 0; i &lt; array.length - 1; i++) {
            int min = i;
            for(int j = i + 1; j &lt; array.length; j++) {
                if(array[min] &gt; array[j]) {
                    min = j;
                }
            }
            int temp = array[i];
            array[i] = array[min];
            array[min] = temp;
        }
    }
</code></pre>
<pre><code class="language-python">print(&#39;This is selection sort&#39;)

def find_smallest(arr):
    smallest = arr[0]
    smallest_index = 0
    for i in range(1, len(arr)):
        if arr[i] &lt; smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index

def selection_sort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest = find_smallest(arr)
        newArr.append(arr.pop(smallest))
    return newArr

print(selection_sort([5,4,6,2,1,123, 2, 3,1,23 ,1,1,]))
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="array-length-property">Array length property</h1>
<p>What is the value of clothes[0]:</p>
<pre><code class="language-javascript">const clothes = [&#39;jacket&#39;, &#39;t-shirt&#39;];
    clothes.length = 0;
    clothes[0];
</code></pre>
<p>Reducing the value of the length property has the side-effect of deleting own array elements whose array index is between the old and new length values.
<a href="https://262.ecma-international.org/6.0/#sec-properties-of-array-instances-length">https://262.ecma-international.org/6.0/#sec-properties-of-array-instances-length</a></p>
<p>As result when JavaScript executes clothes.length = 0, all clothes items are deleted.</p>
<p>clothes[0] is undefined, because clothes array has been emptied.</p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="different-ways-of-declaring-functions-in-js">Different ways of declaring functions in JS</h1>
<p><img src="./different-ways-of-declaring-a-function-in-js.png" alt="Different ways of declaring functions in JS"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="event-loop">Event Loop</h1>
<p><img src="./event-loop.png" alt="Event Loop"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="javascript-data-types">JavaScript data types</h1>
<p><img src="./javascript-data-types.png" alt="JavaScript data types"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="javascript-number-size-summary">JavaScript number size summary</h1>
<p><img src="./javascript-number-size-summary.png" alt="JavaScript number size summary"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="javascript-arrays-cheat-sheet">JavaScript Arrays cheat sheet</h1>
<p><img src="./js-arrays-cheat-sheet.png" alt="JavaScript Arrays cheat sheet"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="possible-types-of-function-in-javascript">Possible types of function in JavaScript</h1>
<p><img src="./possible-types-of-functions-in-js.png" alt="Possible types of function in JavaScript"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="promise-action-flow">Promise action flow</h1>
<p><img src="./promise-action-flow.png" alt="Promise action flow"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="event-bus">Event Bus</h1>
<pre><code class="language-typescript">interface IEventBus {
    channels: any,
    subscribe: (arg1: string, listener: (...args: any[]) =&gt; void) =&gt; void,
    publish: (arg1: string, arg2: any) =&gt; void
}


const EventBus: IEventBus = {
    channels: {},
    subscribe (channelName: string, listener: (...args: any[]) =&gt; void) {
        if (!this.channels[channelName]) {
        this.channels[channelName] = []
        }
        this.channels[channelName].push(listener);
    },
    publish (channelName: string, data: any) {
        const channel = this.channels[channelName];
        if (!channel || !channel.length) {
            return
        }
        channel.forEach((listener: (...args: any[]) =&gt; void) =&gt; listener(data))
    }

}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="observer">Observer</h1>
<pre><code class="language-typescript">export class Observer {
    private observers: any[] = [];

    public subscribe(fn: any) {
        this.observers.push(fn);
    }

    public unsubscribe(fn:any) {
        this.observers = this.observers.filter(subscriber =&gt; subscriber!==fn);
    }

    public next(data:any) {
        this.observers.forEach(subscriber =&gt; subscriber(data));
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="singleton">Singleton</h1>
<pre><code class="language-typescript">const singleton = (function() {
  let instance:any;

  class User {
    public name = &#39;&#39;;
    public age = 0;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
  }
  return {
    getInstance: function(name?: string, age?: number) {
      if(!instance) {
        const newName = name || &quot;&quot;;
        const newAge = age || 0;
        instance = new User(newName, newAge);
      }
      return instance;
    }
  }
})();
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="how-to-reverse-a-number">How to reverse a number?</h1>
<p>To invert a number in Java, you need to divide the number by 10 in the loop until it equals 0. And in the body of the loop find the remainder of the division by 10 and add to the result from the previous step, increased by a factor of 10.</p>
<pre><code class="language-java">    int number = 12132;
    int reverse = 0;
    while(number &gt; 0) {
        reverse = reverse * 10 + number % 10;
        number /= 10;
    }
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="big-o">Big O</h1>
<p><img src="./02-big-o.png" alt="Big O">
<img src="./02-big-o-2.png" alt="Big O 2">
<img src="./02-big-o-3.png" alt="Big O 3"></p>
<p>** Source: <a href="https://github.com/jamiebuilds/itsy-bitsy-data-structures/blob/master/itsy-bitsy-data-structures.js">https://github.com/jamiebuilds/itsy-bitsy-data-structures/blob/master/itsy-bitsy-data-structures.js</a>**</p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="oop-principles">OOP Principles</h1>
<h2 id="abstraction">Abstraction</h2>
<p>Abstract means a concept or an Idea which is not associated with any particular instance. Using abstract class/Interface we express the intent of the class rather than the actual implementation. In a way, one class should not know the inner details of another in order to use it, just knowing the interfaces should be good enough.</p>
<h2 id="inheritance">Inheritance</h2>
<p>Inheritances expresses “is-a” and/or “has-a” relationship between two objects. Using Inheritance, In derived classes we can reuse the code of existing super classes. In Java, concept of “is-a” is based on class inheritance (using extends) or interface implementation (using implements).</p>
<h2 id="encapsulation">Encapsulation</h2>
<p>Encapsulation is the mechanism of hiding of data implementation by restricting access to public methods. Instance variables are kept private and accessor methods are made public to achieve this.</p>
<h2 id="polymorphism">Polymorphism</h2>
<p>It means one name many forms. It is further of two types — static and dynamic. Static polymorphism is achieved using method overloading and dynamic polymorphism using method overriding. It is closely related to inheritance. We can write a code that works on the superclass, and it will work with any subclass type as well.</p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="restful-api-methods">RESTful API methods</h1>
<p><img src="./04-restful-api-methods.png" alt="RESTful API methods"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="types-of-databases">Types of Databases</h1>
<p><img src="./05-types-of-databases.png" alt="Types of Databases"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="software-categories">Software categories</h1>
<p><img src="./06-software-categories.png" alt="Software categories"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="software-characteristics">Software characteristics</h1>
<p><img src="./07-software-characteristics.png" alt="Software characteristics"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="software-development-life-cycle">Software development life cycle</h1>
<p><img src="./08-sdlc.png" alt="Software development life cycle"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="array">Array</h1>
<p>An array is a collection of items stored at contiguous memory locations. The idea is to store multiple items of the same type together. This makes it easier to calculate the position of each element by simply adding an offset to a base value, i.e., the memory location of the first element of the array (generally denoted by the name of the array).</p>
<p><img src="./array.png" alt="Array"></p>
<p>Basic Operations:</p>
<ol>
<li><strong>Traverse</strong> - print all the array elements one by one</li>
<li><strong>Insertion</strong> - adds an element at the given index</li>
<li><strong>Deletion</strong> - deletes an element at the given index</li>
<li><strong>Search</strong> - searches an elem,ent using the given index or by the value</li>
<li><strong>Update</strong> - updates an element at the given index</li>
</ol>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="data-structures-types">Data structures types</h1>
<p><img src="./data-structures-types.png" alt="Data structures types"></p>
<ul>
<li><p>Linear Data Structure: A data structure that includes data elements arranged sequentially or linearly, where each element is connected to its previous and next nearest elements, is referred to as a linear data structure. Arrays and linked lists are two examples of linear data structures.</p>
</li>
<li><p>Non-Linear Data Structure: Non-linear data structures are data structures in which data elements are not arranged linearly or sequentially. We cannot walk through all elements in one pass in a non-linear data structure, as in a linear data structure. Trees and graphs are two examples of non-linear data structures.</p>
</li>
<li><p><a href="../readme.md">Go back</a></p>
</li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="graph">Graph</h1>
<p><img src="./graph.png" alt="Graph">
<img src="./graph-directed.png" alt="Graph directed">
<img src="./graph-undirected.png" alt="Graph undirected">
<img src="./graph-weighted.png" alt="Graph weighted"></p>
<p>Basic Operations:</p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="hash-table">Hash table</h1>
<p><img src="./hash-table.png" alt="Hash table"></p>
<pre><code class="language-typescript">const superPrimitiveHashingFunc = (string: string) =&gt; {
    var hash = 0;
    for (var i = 0; i &lt; string.length; i++) { hash += string.charCodeAt(i); }
    return hash;
}

export class HashTable {
    private collection: any = {}

    public add(key: any, value: any) {
        const theHash = superPrimitiveHashingFunc(key);
        if (!this.collection.hasOwnProperty(theHash)) {
            this.collection[theHash] = {};
        }
        this.collection[theHash][key] = value;
    }

    public remove(key: any) {
        const hashedObj = this.collection[superPrimitiveHashingFunc(key)];
        if (hashedObj.hasOwnProperty(key)) {
            delete hashedObj[key];
        }
        if (!Object.keys(hashedObj).length) {
            delete this.collection[superPrimitiveHashingFunc(key)];
        }
    }

    public lookup(key: any) {
        var theHash = superPrimitiveHashingFunc(key);
        if (this.collection.hasOwnProperty(theHash)) {
            return this.collection[theHash][key];
        }
        return null
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="linked-list">Linked list</h1>
<p><img src="./linked-list.png" alt="Linked List"></p>
<pre><code class="language-typescript">
export class Noddy {
    public element = null;
    public next = null;
    constructor(element: any) {
        this.element = element;
    }
}

export class LinkedList {
    private length = 0;
    private _head: any = null;

    public size() {
        return this.length;
    }

    public head() {
        return this._head;
    }

    public add(element: any) {
        const node = new Noddy(element);
        if (this._head === null) {
            this._head = node;
        } else {
            let currentNode = this._head;
            while (currentNode.next) {
                currentNode = currentNode.next;
            }
            currentNode.next = node;
        }
        this.length++;
    }

    public remove(element: any) {
        let currentNode = this._head;
        let previousNode = null;
        if (currentNode.element === element) {
            this._head = currentNode.next;
        } else {
            while (currentNode.element !== element) {
                previousNode = currentNode;
                currentNode = currentNode.next;
            }

            previousNode.next = currentNode.next;
        }
        this.length -= 1;

    }

    public isEmpty() {
        return !(this.size() &gt; 0);
    }

    public indexOf(element: any) {
        if (this._head === null) return -1;
        let current = this._head;
        let index = 0;
        while (current.element !== element &amp;&amp; current.next !== null) {
            current = current.next;
            index++
        }
        if (current.element !== element &amp;&amp; current.next === null) {
            return -1
        }
        return index;
    }

    public elementAt(index: number) {
        if (this._head === null) return undefined;
        let current = this._head;
        let currentIndex = 0;
        while (currentIndex !== index &amp;&amp; current.next !== null) {
            current = current.next;
            currentIndex++
        }
        if (currentIndex !== index &amp;&amp; current.next === null) {
            return undefined;
        }
        return current.element;
    }

    public removeAt(index: number) {
        if (this._head === null) return undefined;
        let current = this._head;
        let currentIndex = 0;
        while (currentIndex !== index &amp;&amp; current.next !== null) {
            current = current.next;
            currentIndex++
        }
        if (currentIndex !== index &amp;&amp; current.next === null) {
            return null;
        }
        this.remove(current.element)
        return current.element;
    }

    public addAt(index: number, element: any) {
        let node = new Noddy(element);
        if (index &lt; 0 || index &gt; length) {
            return false;
        }
        if (index == 0) {
            node.next = this._head
            this._head = node
            length++;
            return true;
        } else {
            let currentnode = this._head;
            let currentindex = 0;
            let previousnode;
            while (index !== currentindex) {
                previousnode = currentnode;
                currentnode = currentnode.next;
                currentindex++;
            }
            previousnode.next = node;
            node.next = currentnode;
            length++;
            return true
        }
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="map">Map</h1>
<pre><code class="language-typescript">export class Map {

    private collection: any = {}

    public add(key: any, value: any) {
        this.collection[key] = value;

    }

    public delete(key: any) {
        delete this.collection[key]

    }

    public get(key: any) {
        return this.collection[key]

    }

    public has(key: any) {
        return Object.keys(this.collection).includes(key);

    }

    public values() {
        return Object.values(this.collection)

    }

    public size() {
        return Object.keys(this.collection).length

    }

    public clear() {
        this.collection = []

    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="priority-queue">Priority Queue</h1>
<p><img src="./priority-queue.png" alt="priority-queue"></p>
<pre><code class="language-typescript">export class PriorityQueue {
    private collection: any[] = []

    public printCollection() {
        return this.collection;
    }

    public enqueue(element: any) {
        if (this.isEmpty()) {
            return this.collection.push(element);
        }
        this.collection = this.collection.reverse()
        let index = this.collection.findIndex((item) =&gt; {
            return element[1] &gt;= item[1];
        });
        if (index === -1) {
            this.collection.push(element);
        } else {
            this.collection.splice(index, 0, element);
        }
        this.collection = this.collection.reverse()
    }

    public dequeue() {
        if (!this.isEmpty()) {
            return this.collection.shift()[0];
        } else {
            return &quot;The queue is empty.&quot;;
        }
    }

    public front():any {
        return this.collection[0][0]

    }

    public size(): number {
        return this.collection.length

    }

    public isEmpty(): boolean {
        return !this.size();

    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="queue">Queue</h1>
<p><img src="./queue.png" alt="Queue"></p>
<pre><code class="language-typescript">export class Queue {
    private collection: any[] = [];

    public print() {
        return this.collection;
    }

    public enqueue(element: any) {
        this.collection.push(element);
        return element;
    }

    public dequeue() {
        return this.collection.shift();
    }

    public front() {
        return this.collection[0];
    }

    public size() {
        return this.collection.length
    }

    public isEmpty() {
        return !this.collection.length
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="set">Set</h1>
<pre><code class="language-typescript">export class Set {
    private dictionary: any = {}
    private length = 0
    constructor(...elements: any) {
        if (elements.length &gt; 0) {
            elements.forEach((el: any) =&gt; {
                this.add(el);
            });
        }
    }

    public has(element: any) {
        return this.dictionary[element] !== undefined;
    }

    public values() {
        return Object.keys(this.dictionary);
    }

    public add(element: any) {
        if (!this.has(element)) {
            this.dictionary[element] = true;
            this.length++;
            return true;
        }

        return false;
    }

    public delete(element: any) {
        if (this.has(element)) {
            delete this.dictionary[element];
            this.length--;
            return true;
        }

        return false;
    }

    public size() {
        return this.length;
    }

    public union(set: any) {
        const newSet = new Set();
        this.values().forEach((value: any) =&gt; {
            newSet.add(value);
        })
        set.values().forEach((value: any) =&gt; {
            newSet.add(value);
        })

        return newSet;
    }

    public intersection(set: any) {
        const newSet = new Set();

        let big: any;
        let small: any;
        if (this.dictionary.length &gt; set.length) {
            big = this;
            small = set;
        } else {
            big = set;
            small = this;
        }

        small.values().forEach((value: any) =&gt; {
            if (big.dictionary[value]) {
                newSet.add(value);
            }
        })

        return newSet;
    }

    public difference(set:any) {
        const newSet = new Set();

        let big: any;
        let small: any;
        if (this.dictionary.length &gt; set.length) {
            big = this;
            small = set;
        } else {
            big = set;
            small = this;
        }

        small.values().forEach((value: any) =&gt; {
            if (!big.dictionary[value]) {
                newSet.add(value);
            }
        })

        return newSet;
    }

    public isSubsetOf(set: any) {
        let counter = 0;
        this.values().forEach((el) =&gt; {
            if (set.has(el)) {
                counter++;
            }
        });
        return this.values().length === counter;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="stack">Stack</h1>
<p><img src="./stack.png" alt="Stack"></p>
<pre><code class="language-typescript">export class Stack {
    private collection:any[] = [];

    public print() {
        return this.collection;
    }

    public push(element: any) {
        this.collection.push(element);
        return element;
    }

    public pop() {
        return this.collection.pop();
    }

    public peek() {
        return this.collection[this.collection.length - 1];
    }

    public isEmpty() {
        return !this.collection.length;
    }

    public clear() {
        this.collection = []
    }
}
</code></pre>
<pre><code class="language-java">class Stack {
    
    int[] stack;
    int top, capacity, currentSize;
    
    public Stack (int capacity) {
        this.capacity = capacity;
        top = -1;
        currentSize = 0;
        stack = new int[this.capacity];
    }

    public boolean isEmpty() {
        return currentSize == 0;
    }
    
    public int size() {
        return currentSize;
    }
    
    public int top() {
        if(top &lt; 0){
            return -1;
        }
        return stack[top];
    }
    
    public void push(int element) {
        if(top &gt;= capacity - 1) {
            return;
        }
        stack[++top] = element;
        currentSize++;
    }
    
    public void pop() {
        if(top &lt; 0) {
            return;
        }
        top--;
        currentSize--;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="tree">Tree</h1>
<p><img src="./tree1.png" alt="Tree1">
<img src="./tree2.png" alt="Tree2"></p>
<h2 id="tree-1">Tree</h2>
<pre><code class="language-javascript">class Tree {
  constructor() {
    this.root = null;
  }

  traverse(callback) {
    function walk(node) {
      callback(node);
      node.children.forEach(walk);
    }
    walk(this.root);
  }

  add(value, parentValue) {
    let newNode = {
      value,
      children: []
    };

    if (this.root === null) {
      this.root = newNode;
      return;
    }

    this.traverse(node =&gt; {
      if (node.value === parentValue) {
        node.children.push(newNode);
      }
    });
  }
}
</code></pre>
<h2 id="binary-search-tree">Binary search tree</h2>
<pre><code class="language-javascript">
class BinarySearchTree {

  constructor() {
    this.root = null;
  }

  contains(value) {
    let current = this.root;

    while (current) {

      if (value &gt; current.value) {
        current = current.right;

      } else if (value &lt; current.value) {
        current = current.left;

      } else {
        return true;
      }
    }

    return false;
  }

  add(value) {
    let node = {
      value: value,
      left: null,
      right: null
    };

    if (this.root === null) {
      this.root = node;
      return;
    }

    let current = this.root;

    while (true) {

      if (value &gt; current.value) {

        if (!current.right) {
          current.right = node;
          break;
        }

        current = current.right;

      } else if (value &lt; current.value) {

        if (!current.left) {
          current.left = node;
          break;
        }

        current = current.left;

      } else {
        break;
      }
    }
  }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="horizontal-and-vertical-scaling">Horizontal and vertical scaling</h1>
<p>Scalability refers to an application’s ability to handle and withstand an increased workload without sacrificing latency. An application needs solid computing power to scale well. The servers should be powerful enough to handle increased traffic loads. There are two main ways to scale an application: horizontally and vertically.</p>
<p>Horizontal scaling, or scaling out, means adding more hardware to the existing hardware resource pool. It increases the computational power of the system as a whole. Vertical scaling, or scaling up, means adding more power to your server. It increases the power of the hardware running the application.</p>
<p><img src="./01-horizontal-vertical-scaling.png" alt="Horizontal and vertical scaling"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="cap-theorem">CAP theorem</h2>
<p>CAP(Consistency-Availability-Partition Tolerance) theorem says that a distributed system cannot guarantee C, A and P simultaneously. It can at max provide any 2 of the 3 guarantees. Let us understand this with the help of a distributed database system. </p>
<p>Consistency: This states that the data has to remain consistent after the execution of an operation in the database. For example, post database updation, all queries should retrieve the same result.
Availability: The databases cannot have downtime and should be available and responsive always.
Partition Tolerance: The database system should be functioning despite the communication becoming unstable.
The following image represents what databases guarantee what aspects of the CAP Theorem simultaneously. We see that RDBMS databases guarantee consistency and Availability simultaneously. Redis, MongoDB, Hbase databases guarantee Consistency and Partition Tolerance. Cassandra, CouchDB guarantees Availability and Partition Tolerance.</p>
<p><img src="./02-cap-theorem.png" alt="CAP theorem"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="how-dns-resolves-ip-address">How DNS resolves ip address</h2>
<p><img src="./03-how-dns-resolves-ip.png" alt="How dns resolves ip"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="single-server-setup">Single server setup</h2>
<p><img src="./04-single-server-setup.png" alt="Single server setup"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="database--single-servers-setup">Database + Single servers setup</h2>
<p><img src="./05-database-single-servers-setup.png" alt="Database + single servers setup"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="load-balancer">Load balancer</h2>
<p><img src="./06-load-balancer.png" alt="Load balancer"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="database-replication">Database replication</h2>
<p><img src="./07-database-replication.png" alt="Database replication"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="web-tier--data-tier--load-balancer-system-design">Web tier + Data tier + Load balancer System design</h2>
<p><img src="./08-web-tier-data-tier-load-balancer-system-desing.png" alt="Web tier + Data tier + Load balancer System design"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="cache-tier">Cache tier</h2>
<p><img src="./09-cache-tier.png" alt="Cache tier"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="cdn-workflow">CDN Workflow</h2>
<p><img src="./10-cdn-workflow.png" alt="CDN Workflow"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="web-tier--data-tier--load-balancer--cache--cdn-system-design">Web tier + Data tier + Load balancer + Cache + CDN System design</h2>
<p><img src="./11-web-tier-data-tier-load-balancer-cache-cdn-system-design.png" alt="Web tier + Data tier + Load balancer + Cache + CDN System design"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="stateful-architecture">Stateful architecture</h2>
<p><img src="./12-stateful-architecture.png" alt="Stateful architecture"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="stateless-architecture">Stateless architecture</h2>
<p><img src="./13-stateless-architecture.png" alt="Stateless architecture"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="web-tier--data-tier--load-balancer--cache--cdn-stateless-system-design">Web tier + Data tier + Load balancer + Cache + CDN stateless System design</h2>
<p><img src="./14-web-tier-data-tier-load-balancer-cache-cdn-stateless-system-design.png" alt="Web tier + Data tier + Load balancer + Cache + CDN stateless System design"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="system-design-with-data-centers">System design with data centers</h2>
<p><img src="./15-system-design-with-data-centres.png" alt="System design with data centers"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="message-queue">Message queue</h2>
<p><img src="./16-message-queue.png" alt="Message queue"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="system-design-with-message-queue">System design with message queue</h2>
<p><img src="./17-system-design-with-message-queue.png" alt="System design with message queue"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="round-robin">Round robin</h2>
<p><img src="./18-round-robin.png" alt="Round robin"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="sticky-round-robin">Sticky round robin</h2>
<p><img src="./19-sticky-round-robin.png" alt="Sticky round robin"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="weighted-round-robin">Weighted round robin</h2>
<p><img src="./20-weighted-round-robin.png" alt="Sticky round robin"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="ipurl-hash">IP/URL hash</h2>
<p><img src="./21-ip-url-hash.png" alt="IP/URL hash"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="least-connections">Least connections</h2>
<p><img src="./22-least-connections.png" alt="Least connections"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="least-time">Least time</h2>
<p><img src="./23-least-time.png" alt="Least time"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="simplified-continuous-integration-flow">Simplified Continuous integration flow</h2>
<p><img src="./24-simplified-continious-integration-flow.png" alt="Least time"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h2 id="architectural-characteristics">Architectural characteristics</h2>
<p><img src="./25-architectual-characteristics.png" alt="Least time"></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="3sum">3Sum</h1>
<pre><code class="language-typescript">
function threeSum(nums: number[]): number[][] {
    nums.sort((a, b) =&gt; a - b);

    const triplets = [];

    for (let i = 0; i &lt; nums.length; i++) {

        if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) {
            continue;
        }

        let j = i + 1;
        let k = nums.length - 1;

        while (j &lt; k) {
            if (nums[i] + nums[j] + nums[k] === 0) {
                triplets.push([nums[i], nums[j], nums[k]]);
                j++;
                while (j &lt; k &amp;&amp; nums[j] === nums[j - 1]) {
                    j++;
                }
            } else if (nums[i] + nums[j] + nums[k] &lt; 0) {
                j++;
            } else {
                k--;
            }
        }
    }
    return triplets;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="add-binary">Add binary</h1>
<pre><code class="language-typescript">
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    let result = &quot;&quot;;
    let i = a.length - 1;
    let j = b.length - 1;
    let carry = 0;
    while (i &gt;= 0 || j &gt;= 0) {
        let sum = carry;
        if (i &gt;= 0) {
            sum += a[i--] - &#39;0&#39;;
        }
        if (j &gt;= 0) {
            sum += b[j--] - &#39;0&#39;;
        }
        result = sum % 2 + result;
        carry = parseInt(sum / 2);
    }
    if (carry &gt; 0) {
        result = 1 + result;
    }
    return result;
};
</code></pre>
<p>Time complexity: O(n)
Space complexity: O(n)</p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="add-two-numbers">Add Two Numbers</h1>
<pre><code class="language-typescript">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {

    let head = null

    let temp = null;

    let carry = 0;

    while(l1 !== null || l2 !== null) {
        let sum = carry;
        if(l1 !== null) {
            sum += l1.val;
            l1 = l1.next;
        }
        if(l2 !== null) {
             sum += l2.val;
            l2 = l2.next;
        }

        const node = new ListNode(Math.floor(sum) % 10);
        carry = Math.floor(sum / 10);
        if(temp === null) {
            temp = node;
            head = node;
        } else {
            temp.next = node;
            temp = temp.next;
        }
    }

    if(carry &gt; 0) {
        temp.next = new ListNode(carry);
    }


    return head;

};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="adjacency-list-to-adjacency-matrix">Adjacency list to adjacency matrix</h1>
<pre><code class="language-java">class Solution {
    int[][] adjListToMatrix(int n, ArrayList&lt;Integer&gt;[] adjList) {
        int [][] matrix = new int[n][n];

        for(int i = 0; i &lt; n; i++) {
            for(int j = 0; j &lt; adjList[i].size(); j++) {
                matrix[i][adjList[i].get(j)] = 1;
            }
        }
        
        return matrix;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="adjacency-matrix-to-adjacency-list">Adjacency matrix to adjacency list</h1>
<pre><code class="language-java">class Solution {
    ArrayList&lt;Integer&gt;[] matrixToAdjList(int n, int[][] matrix) {
        ArrayList&lt;Integer&gt;[] adjList = new ArrayList [n];
        for(int i = 0; i &lt; n; i++) {
            adjList[i] = new ArrayList&lt;Integer&gt;();
        }
        
        for(int i = 0; i &lt; n; i++) {
            for(int j = 0; j &lt; n; j++) {
                if(matrix[i][j] == 1) {
                    adjList[i].add(j);
                }
            }
        }
        return adjList;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="arithmetic-sequence">Arithmetic sequence</h1>
<pre><code class="language-java">class Solution {
    boolean isArithmeticSequence (int[] arr) {
        int length = arr.length;
        if(length == 1) {
            return true;
        }
        
        Arrays.sort(arr);
        int diff = arr[1] - arr[0];
        for(int i = 1; i &lt; length; i++) {
            if(arr[i] - arr[i-1] != diff) {
                return false;
            }
        }
        return true;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="balanced-binary-tree">Balanced Binary Tree</h1>
<pre><code class="language-typescript">
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function isBalanced(root: TreeNode | null): boolean {
    if(root === null) return true;
    if(height(root) === -1) return false;
    return true;
};

function height(node: TreeNode): number {
    if(node == null) return 0;

    const left = height(node.left)
    const right = height(node.right);

    if(left === -1 || right === -1) return -1;
    if(Math.abs(left - right) &gt; 1) return -1;

    return Math.max(left, right) + 1;
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="balanced-brackets">Balanced brackets</h1>
<pre><code class="language-typescript">
const tokens = {
    &#39;{&#39;: &#39;}&#39;,
    &#39;[&#39;: &#39;]&#39;,
    &#39;(&#39;: &#39;)&#39;
}
function isOpenTerm(s) {
    return tokens[s];
}

function matches(first, second) {
    for(let item in tokens) {
        if(item === first) {
           return tokens[item] === second
       } 
    }
    return false;
}

function isBalanced(s) {
    // Write your code here
   const stack = [];
   for(let i = 0; i &lt; s.length; i++) {
       if(isOpenTerm(s[i])) {
           stack.push(s[i]);
       } else {
           if(stack.length === 0 || !matches(stack.pop(), s[i])) {
               return &#39;NO&#39;;
           }
       }
   }
   return stack.length === 0 ? &#39;YES&#39; : &#39;NO&#39;
}
</code></pre>
<p>** Source: <a href="http://hackerrank.com">http://hackerrank.com</a>**</p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="best-time-to-buy-and-sell-stock">Best Time to Buy and Sell Stock</h1>
<pre><code class="language-typescript">function maxProfit(prices: number[]): number {
        let min = 10000;
        
        let maxDiff = 0;
        for (let i = 0; i &lt; prices.length; i++){
            min = Math.min(prices[i], min);
            maxDiff = Math.max(prices[i] - min, maxDiff);
         }
        return maxDiff;

};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="big-countries">Big countries</h1>
<pre><code class="language-sql">SELECT name, population, area FROM World WHERE population &gt;= 25000000 OR area &gt;= 3000000;
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="binary-tree-inorder-traversal">Binary Tree Inorder Traversal</h1>
<pre><code class="language-typescript">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function inorderTraversal(root: TreeNode | null): number[] {
    const list = [];
    const stack = [];
    let node = root;

    while(node !== null || stack.length &gt; 0) {
        while(node !== null) {
            stack.push(node);
            node = node.left
        }
        list.push(stack[stack.length -1].val);
        let el = stack.pop();
        node = el.right;
    }
    return list;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="binary-tree-paths">Binary Tree Paths</h1>
<pre><code class="language-typescript">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function binaryTreePaths(root: TreeNode | null): string[] {
    const responce: string[] = [];
    helper(root, &quot;&quot;, responce);
    return responce;
};

function helper(root: TreeNode, path: string, responce: string[]) {
    if (root == null) { return; }

    if (root.left == null &amp;&amp; root.right == null) {
        responce.push(path + root.val);
        return;
    }

    helper(root.left, path + root.val + &quot;-&gt;&quot;, responce);
    helper(root.right, path + root.val + &quot;-&gt;&quot;, responce);
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="binary-tree-postorder-traversal">Binary Tree Postorder Traversal</h1>
<pre><code class="language-typescript">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function postorderTraversal(root: TreeNode | null): number[] {
  var res = [];
  helper(root, res);
  return res;
};

const helper = function (root, res) {
  if (!root) return;
  helper(root.left, res);
  helper(root.right, res);
  res.push(root.val);
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="binary-tree-preorder-traversal">Binary Tree Preorder Traversal</h1>
<pre><code class="language-typescript">
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function preorderTraversal(root: TreeNode | null): number[] {
    const output: any[] = [];
    preorder(root, output);
    return output;
};

function preorder(root: TreeNode | null, output: any[]) {
    if (root == null) return;

    output.push(root.val);
    preorder(root.left, output);
    preorder(root.right, output);
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="chain-adding-functions">Chain adding functions</h1>
<p>Multiple calls:</p>
<p>add(1)(2)(3); // 6
add(1)(2)(3)(4); // 10
add(1)(2)(3)(4)(5); // 15</p>
<p>Single call:
add(1); // 1</p>
<p>Mixed thing:
let addTwo = add(2);
addTwo; // 2
addTwo + 5; // 7
addTwo(3); // 5
addTwo(3)(5); // 10</p>
<pre><code class="language-typescript">function add(x: number): any {
    let sum = x;
    function f(y: number) {
      sum += y;
      return f;
    }
    f.toString = function() {
      return sum;
    };
    return f;
  }
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="chain-calculator">Chain calculator</h1>
<pre><code class="language-typescript">function ChainCalculator(given) {
    this.num = given || 0;
    const actions = {
        half: [&#39;this.num = this.num/2; return this;&#39;],
        quarter: [&#39;this.num = this.num/4; return this;&#39;],
        third: [&#39;this.num = this.num/3; return this;&#39;],
        pow: [&#39;given&#39;, &#39;this.num = Math.pow(this.num, given); return this;&#39;],
        sqrt: [&#39;this.num = Math.sqrt(this.num); return this;&#39;],
        log: [`console.log(this.num); return this;`],
        sum: [&#39;given&#39;,`this.num += given; return this;`],
        minus: [&#39;given&#39;,`this.num -= given; return this;`],
        multiply: [&#39;given&#39;,`this.num *= given; return this;`],
        divide: [&#39;given&#39;,`this.num /= given; return this;`],
        finish: [&#39;return this.num;&#39;]
    }

    for(const key in actions) {
        this[key] = new Function(...actions[key])
    }
}
const calculator = new ChainCalculator();

calculator.log().sum(15).log().sum(10).log().finish().log()
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="climbing-stairs">Climbing stairs</h1>
<pre><code class="language-typescript">function climbStairs(n: number): number {
    if(n &lt;= 3) {
        return n;
    }

    let a = 3;
    let b = 2;

    for(let i = 0; i &lt; n -3; i++) {
        a = a + b;
        b = a - b;
    }
    return a;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="combine-two-tables">Combine Two Tables</h1>
<pre><code class="language-SQL">select p.FirstName, p.LastName, a.City, a.State from person p
left join address a on p.personid = a.personid
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="container-with-most-water">Container With Most Water</h1>
<pre><code class="language-typescript">function maxArea(height: number[]): number {

    let maximumArea = Number.MIN_SAFE_INTEGER;
    let left = 0;
    let right = height.length - 1;
    while (left &lt; right) {

        let shorterLine = Math.min(height[left], height[right]);

        maximumArea = Math.max(maximumArea, shorterLine * (right - left));

        if (height[left] &lt; height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return maximumArea;

};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="contains-duplicates-2">Contains Duplicates 2</h1>
<pre><code class="language-typescript">function containsNearbyDuplicate(nums: number[], k: number): boolean {
    const seen: any = new Map();
    for (let i = 0; i &lt; nums.length; ++i) {
      if (i - seen.get(nums[i]) &lt;= k) {
        return true;
      }
        seen.set(nums[i], i);
    }
    return false;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="contains-duplicate">Contains Duplicate</h1>
<pre><code class="language-typescript">function containsDuplicate(nums: number[]): boolean {
        nums.sort((a: any, b: any) =&gt; a-b);
        for(let i = 0; i &lt; nums.length -1; i++) {
            if(nums[i] === nums[i+1]) {
                return true;
            }
        }
        return false;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="convert-sorted-array-to-binary-search-tree">Convert Sorted Array to Binary Search Tree</h1>
<pre><code class="language-typescript">
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function sortedArrayToBST(nums: number[]): TreeNode | null {
    return helper(nums, 0, nums.length - 1);
};


function helper(nums: number[], start:number, end: number) {
    if(start &gt; end) return null;
    let mid = Math.trunc((start + end) / 2);
    let node = new TreeNode(nums[mid]);
    node.left = helper(nums, start, mid -1);
    node.right = helper(nums, mid + 1, end);
    return node
}
</code></pre>
</span></li><li><h1></h1><hr/><span><h1 id="cumulative-sum">Cumulative Sum</h1>
<pre><code class="language-java">class Solution {
    int[] getCumulativeSum (int[] arr) {
        int[] out = new int[arr.length];
        int total = 0;
        for(int i = 0; i &lt; arr.length; i++) {
            total += arr[i];
            out[i] = total;
        }
        return out;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="curry-function">Curry function</h1>
<pre><code class="language-typescript">function curry(func: any) {
    const curried = (...args: any) =&gt; {
        if(args.length &gt;= func.length) {
            return func.apply(this, args);
        } else {
            return (...args2: any) =&gt; {
                return curried.apply(this, args.concat(args2))
            }
        }
    };
    return curried;
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="customers-who-never-order">Customers Who Never Order</h1>
<pre><code class="language-SQL">SELECT Name AS Customers FROM Customers WHERE Id NOT IN( SELECT CustomerId FROM Orders);
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="delete-duplicate-emails">Delete Duplicate Emails</h1>
<pre><code class="language-sql">delete A from Person A, Person B where A.id &gt; B.id and A.email=B.email;
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="duplicate-emails">Duplicate Emails</h1>
<pre><code class="language-sql">select `Email` from `Person` group by `Email` having count(*) &gt; 1
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="employees-earning-more-than-their-managers">Employees Earning More Than Their Managers</h1>
<pre><code class="language-sql">SELECT a.Name AS Employee
FROM Employee a, Employee b
WHERE a.ManagerId = b.Id AND a.Salary &gt; b.Salary
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="even-number-of-digits">Even number of digits</h1>
<pre><code class="language-java">class Solution {
    int countOfDigits(int number) {
        if(number == 0) {
            return 1;
        }
        int count = 0;
        while(number &gt; 0) {
            count++;
            number /= 10;
        }
        return count;
    }
        
    
    List&lt;Integer&gt; getEvenDigitNumbers (int[] arr) {
        // add your logic here
        List&lt;Integer&gt; output = new ArrayList&lt;Integer&gt;();

        for(int i = 0; i &lt; arr.length; i++) {
            if(countOfDigits(arr[i]) % 2 == 0) {
                output.add(arr[i]);
            }
        }
        return output; 
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="excel-sheet-column-title">Excel Sheet Column Title</h1>
<pre><code class="language-typescript">function convertToTitle(columnNumber: number): string {
      let output = [];
        while (columnNumber &gt; 0) {
            let j = columnNumber % 26;
            if (j == 0) {
                output.push(&quot;Z&quot;);
                columnNumber = Math.floor(columnNumber / 26) - 1;
            }
            else {
                output.push(String.fromCharCode((j - 1) + &#39;A&#39;.charCodeAt(0)));
                columnNumber = Math.floor(columnNumber / 26);
            }
        }
    return output.reverse().join(&quot;&quot;);
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="fibonacci-streaming">Fibonacci streaming</h1>
<pre><code class="language-typescript">export function fibonacciSequence(): Iterator&lt;number&gt; {
    let index = 0;
    let prev = 0;
    let value = 1;
  
    return {
      next: () =&gt; {
        if (index &gt;= Infinity) { 
            return { value: value, done: true }; 
        }
  
        let result = { value, done: false };
        let next = value + prev;
        prev = value;
        value = next;
        index++;
  
        return result;
      }
    }
  }
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="find-the-difference">Find the Difference</h1>
<pre><code class="language-typescript">
function findTheDifference(s: string, t: string): string {
  let sArr = s.split(&#39;&#39;).sort()
  let tArr = t.split(&#39;&#39;).sort()
    for( let i = 0; i &lt; tArr.length; i++){
    
    if( sArr[i] !== tArr[i]){

      return tArr[i];
    }
  } 
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="find-the-index-of-the-first-occurrence-in-a-string">Find the Index of the First Occurrence in a String</h1>
<pre><code class="language-typescript">function strStr(haystack: string, needle: string): number {
    const haystackLength = haystack.length;
    const needleLength = needle.length;

    for(let i = 0; i &lt; haystackLength - needleLength + 1; i++) {
        if (haystack.substring(i, i + needleLength) === needle) {
            return i;
        }
    }
    return -1;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="find-the-median">Find the median</h1>
<pre><code class="language-typescript">function findMedian(arr: number[]): number {
    arr = arr.sort((a,b) =&gt; a - b);
    return arr[Math.floor(arr.length / 2)];
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="find-the-pivot-integer">Find the Pivot Integer</h1>
<pre><code class="language-typescript">function pivotInteger(n: number): number {
    let total = (n * (n +1)) / 2;
    let sum = 0;
    for(let i = 1; i &lt;= n; i++) {
        sum += i;
        if(sum === (total - sum + i)) {
            return i;
        }
    }
    return -1;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="first-unique-character-in-a-string">First Unique Character in a String</h1>
<pre><code class="language-typescript">function firstUniqChar(s: string): number {
   let map = [];
    for (let i = 0; i &lt; s.length; i++) {
        if(map[s[i]]) {
            map[s[i]]++;
        } else {
            map[s[i]] = 1;
        }
    }
    for (let i = 0; i &lt; s.length; i++) {
        if (map[s[i]] === 1) {
            return i;
        }
    }
    return -1;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="first-bad-version">First Bad Version</h1>
<pre><code class="language-typescript">
/**
 * The knows API is defined in the parent class Relation.
 * isBadVersion(version: number): boolean {
 *     ...
 * };
 */

var solution = function(isBadVersion: any) {

    return function(n: number): number {
        let left = 1, right = n
        while(left &lt; right) {
            const mid = left + Math.floor((right-left)/2)
            if(isBadVersion(mid)) {
                right = mid
            } else {
                left = mid + 1
            }
        }
        return left
    };
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="fizz-buzz">Fizz Buzz</h1>
<pre><code class="language-typescript">function fizzBuzz(n: number): string[] {

    let output: any = [];
      for (let i = 1; i &lt;= n; i++) {
            if (i % 3 == 0 &amp;&amp; i % 5 == 0) {
                output.push(&quot;FizzBuzz&quot;);
            } else if (i % 3 == 0) {
                output.push(&quot;Fizz&quot;);
            } else if (i % 5 == 0) {
                output.push(&quot;Buzz&quot;);
            } else {
                output.push(i.toString());
            }
        }
        return output;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="generate-parentheses">Generate Parentheses</h1>
<pre><code class="language-typescript">function generateParenthesis(n: number): string[] {
    const result = [];
    generator(result, &quot;&quot;, 0,0,n)
    return result;
};

function generator(result, s, open, close, n) {
    if(open === n &amp;&amp; close === n) {
        result.push(s);
        return;
    }
    if(open &lt; n) {
         generator(result, s + &#39;(&#39;, open +1, close, n);
    }
    if(close &lt; open) {
         generator(result, s + &#39;)&#39;, open, close + 1, n);
    }
    
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="happy-number">Happy Number</h1>
<pre><code class="language-typescript">
function isHappy(n: number): boolean {
    let slow = n;
    let fast = getNextSum(n);
    while(fast !== 1 &amp;&amp; slow !== fast) {
        slow = getNextSum(slow);
        fast = getNextSum(getNextSum(fast));
    }
    return fast === 1;
};

const getNextSum = (number) =&gt; {
    let sum = 0;
    while(number &gt; 0) {
        let digit = number % 10;
        sum += digit * digit;
        number = Math.floor(number / 10);
    }
    return sum;
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="identical-twins">Identical twins</h1>
<pre><code class="language-java">class Solution {
    int getIdenticalTwinsCount (int[] arr) {
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for (int i = 0; i &lt; arr.length; i++) {
            Integer val = map.get(arr[i]);
            if(val == null) {
                map.put(arr[i],1);
            } else {
                map.put(arr[i], ++val);
            }
        }
                
        int count = 0;
        for(Map.Entry&lt;Integer, Integer&gt; y: map.entrySet()){
            int x = (y.getValue() * (y.getValue() - 1)) / 2;
            count += x;
            
        }
        return count;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="implement-queue-using-stacks">Implement Queue using Stacks</h1>
<pre><code class="language-typescript">class MyQueue {
    stack1: number[] = [];
    stack2: number[] = [];

    constructor() {}

    push(x: number): void {
        this.stack1.push(x);
    }

    pop(): number {
        this.move();
        return this.stack2.pop();
    }

    peek(): number {
        this.move();
        return this.stack2[this.stack2.length - 1];
    }

    empty(): boolean {
        return !this.stack1.length &amp;&amp; !this.stack2.length;
    }

    move(): void {
        if (!this.stack2.length) {
            while (this.stack1.length) {
                this.stack2.push(this.stack1.pop());
            }
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="implement-stack-using-queues">Implement Stack using Queues</h1>
<pre><code class="language-typescript">class MyStack {
    public arr: any = [];
    constructor() {

    }

    push(x: number): void {
        const newq = [];
        newq.push(x);
        while (this.arr.length &gt; 0) {
            newq.push(this.arr.shift());
        }
        this.arr = newq;
    }

    pop(): number {
        return this.arr.shift();
    }

    top(): number {
        return this.arr[0];
    }

    empty(): boolean {
        return this.arr.length === 0;
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="integer-to-roman">Integer to Roman</h1>
<pre><code class="language-typescript">
function intToRoman(num: number): string {
    const M = [&#39;&#39;, &#39;M&#39;, &#39;MM&#39;, &#39;MMM&#39;];
    const C = [&#39;&#39;, &#39;C&#39;, &#39;CC&#39;, &#39;CCC&#39;, &#39;CD&#39;, &#39;D&#39;, &#39;DC&#39;, &#39;DCC&#39;, &#39;DCCC&#39;, &#39;CM&#39;];
    const X = [&#39;&#39;, &#39;X&#39;, &#39;XX&#39;, &#39;XXX&#39;, &#39;XL&#39;, &#39;L&#39;, &#39;LX&#39;, &#39;LXX&#39;, &#39;LXXX&#39;, &#39;XC&#39;];
    const I = [&#39;&#39;, &#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IV&#39;, &#39;V&#39;, &#39;VI&#39;, &#39;VII&#39;, &#39;VIII&#39;, &#39;IX&#39;];

    return (
        M[Math.floor(num / 1000)] +
        C[Math.floor((num % 1000) / 100)] +
        X[Math.floor((num % 100) / 10)] +
        I[num % 10]
    );
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="intersection-of-two-arrays-2">Intersection of two arrays 2</h1>
<pre><code class="language-typescript">
function intersect(nums1: number[], nums2: number[]): number[] {
    let output: number[] = [];
    nums1.sort((a,b) =&gt; a-b);
    nums2.sort((a,b) =&gt; a-b);

    let i = 0;
    let j = 0;
    while(i &lt; nums1.length &amp;&amp; j &lt; nums2.length) {
        if(nums1[i] === nums2[j]) {
            output.push(nums1[i]);
            i++;
            j++
        } else if(nums1[i] &lt; nums2[j]) {
            i++
        } else {
            j++
        }
    }
    return output;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="intersection-of-two-linked-lists">Intersection of Two Linked Lists</h1>
<pre><code class="language-typescript">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {
    let pointer1 = headA;
    let pointer2 = headB;

    while(pointer1 !== pointer2) {
        pointer1 = pointer1 === null ? headB: pointer1.next;
        pointer2 = pointer2 === null ? headA: pointer2.next;
        
    }
    return pointer1;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="inventory-update">Inventory update</h1>
<pre><code class="language-typescript">function updateInventory(arr1: any, arr2: any) {
  const inventory = [...arr1]

  for (let i = 0; i &lt; arr2.length; i++) {
    const item = arr2[i][1];
    const quantity = arr2[i][0];

    const position = inventory.indexOf(item);

    if (position !== -1) {
      const row = Math.floor(position / 2);
      arr1[row][0] += quantity;
      continue;
    }

    arr1.push([quantity, item]);
  }

  arr1.sort((previous: any, next: any) =&gt; (previous[1] &gt; [next[1]] ? 1 : -1));

  return arr1;
}

var curInv = [
  [21, &quot;Bowling Ball&quot;],
  [2, &quot;Dirty Sock&quot;],
  [1, &quot;Hair Pin&quot;],
  [5, &quot;Microphone&quot;],
];

var newInv = [
  [2, &quot;Hair Pin&quot;],
  [3, &quot;Half-Eaten Apple&quot;],
  [67, &quot;Bowling Ball&quot;],
  [7, &quot;Toothpaste&quot;],
];
const result =  updateInventory(curInv, newInv);
console.log(result)
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="invert-binary-tree">Invert Binary Tree</h1>
<pre><code class="language-typescript">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function invertTree(root: TreeNode | null): TreeNode | null {
    if (root == null) return null;

    const left = root.left;
    const right = root.right;
    root.left = invertTree(right);
    root.right = invertTree(left);
    return root;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="isomorphic-strings">Isomorphic Strings</h1>
<pre><code class="language-typescript">function isIsomorphic(s: string, t: string): boolean {
       if(s.length != t.length) return false;
        const m1 = [];
        const m2 = [];
        for(let i=0; i&lt; s.length; i++){
            if(m1[s[i]] != m2[t[i]]) return false;

            m1[s[i]] = i+1;
            m2[t[i]] = i+1;
        }

        return true;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="length-of-last-word">Length of Last Word</h1>
<pre><code class="language-typescript">function lengthOfLastWord(s: string): number {
    s = s.trim();
    let counter = 0;
    for(let i = s.length - 1; i &gt;= 0; i--) {
        if(s[i] === &#39; &#39;) {
            break;
        }
        counter++;
    }

    return counter;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="linked-list-cycle">Linked List Cycle</h1>
<pre><code class="language-typescript">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {

    let slowNode = head;
    let fastNode = head;

    while(fastNode !== null &amp;&amp; fastNode.next !== null) {
        fastNode = fastNode.next.next;
        slowNode = slowNode.next;

        if(fastNode === slowNode) {
            return true
        }
    }
    
    return false;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="lonely-integer">Lonely Integer</h1>
<pre><code class="language-typescript">function lonelyInteger(a: number[]): number {
    return a.reduce((a: number, b: number) =&gt; a^b);
}

,,,

* [Go back](../readme.md)
</code></pre>
</span></li><li><h1></h1><hr/><span><h1 id="longest-common-prefix">Longest common prefix</h1>
<pre><code class="language-typescript">function longestCommonPrefix(strs: string[]): string {
    const size = strs.length;
    if(size === 0) return &quot;&quot;;
    if(size === 1) return strs[0];

    strs.sort();

    let end = Math.min(strs[0].length, strs[size - 1].length);
    let i = 0;

    while(i &lt; end &amp;&amp; strs[0][i] === strs[size - 1][i]) {
        i++
    }

    const output = strs[0].substring(0, i);
    return output;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="longest-palindrome">Longest palindrome</h1>
<pre><code class="language-typescript">function longestPalindrome(s: string): string {

    let length = s.length;
    let maxLength = 1;
    let start = 0;

    let table = new Array(length);
    for(let i = 0; i &lt; length; i++) {
        table[i] = new Array(length);
    }

    for(let i = 0; i &lt; length; i++) {
        table[i][i] = true;
    }

    for(let i = 0; i &lt; length; i++) {
        if(s[i] === s[i+1]) {
            table[i][i + 1] = true;
            start = i;
            maxLength = 2;
        }
    }

    for(let k = 3; k &lt;= length; k++) {
        for(let i = 0; i &lt; length - k + 1; i++) {
            let j = i + k - 1;

            if(table[i + 1][j - 1] &amp;&amp; s[i] == s[j]) {
                table[i][j] = true;
                if(k &gt; maxLength) {
                    start = i;
                    maxLength = k;
                }

            }
        }
    }

    
    return s.slice(start, start + maxLength);
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="longest-palindromic-substring">Longest Palindromic Substring</h1>
<pre><code class="language-typescript">function longestPalindrome(s: string): string {

    let length = s.length;
    let maxLength = 1;
    let start = 0;

    let table = new Array(length);
    for(let i = 0; i &lt; length; i++) {
        table[i] = new Array(length);
    }

    for(let i = 0; i &lt; length; i++) {
        table[i][i] = true;
    }

    for(let i = 0; i &lt; length; i++) {
        if(s[i] === s[i+1]) {
            table[i][i + 1] = true;
            start = i;
            maxLength = 2;
        }
    }

    for(let k = 3; k &lt;= length; k++) {
        for(let i = 0; i &lt; length - k + 1; i++) {
            let j = i + k - 1;

            if(table[i + 1][j - 1] &amp;&amp; s[i] == s[j]) {
                table[i][j] = true;
                if(k &gt; maxLength) {
                    start = i;
                    maxLength = k;
                }

            }
        }
    }

    
    return s.slice(start, start + maxLength);
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="longest-substring-without-repeating-characters">Longest Substring Without Repeating Characters</h1>
<pre><code class="language-typescript">function lengthOfLongestSubstring(s: string): number {
    if(s.length === 0) return 0;

    let start = 0;
    let end = 0;
    let maxLength = 0;
    const stringSet = new Set&lt;string&gt;();

    while(end &lt; s.length) {
        if(!stringSet.has(s[end])) {
            stringSet.add(s[end]);
            end++;
            maxLength = Math.max(maxLength, stringSet.size);
        } else {
            stringSet.delete(s[start]);
            start++;
        }
    }

    return maxLength;

};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="majority-element">Majority Element</h1>
<pre><code class="language-typescript">function majorityElement(nums: number[]): number {

    let count =0;
    let res = 0;

    for(let i = 0; i&lt;=nums.length; i++) {
            if (count==0) {
                res = nums[i];
            }
            if (nums[i]!=res) {
                count--;
            }
            else {
                count++;
           }
    }
    return res;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="maximum-depth-of-binary-tree">Maximum Depth of Binary Tree</h1>
<pre><code class="language-typescript">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function maxDepth(root: TreeNode | null): number {
    if(root === null) return 0;
    else {
        let leftDepth = maxDepth(root.left);
        let rightDepth = maxDepth(root.right);
        if(leftDepth &gt; rightDepth) return leftDepth + 1;
        else return rightDepth + 1;
    }

};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="median-of-two-sorted-arrays">Median of two sorted arrays</h1>
<pre><code class="language-typescript">function findMedianSortedArrays(nums1: number[], nums2: number[]): number {
    if(nums1.length &gt; nums2.length) {
        return findMedianSortedArrays(nums2, nums1);
    }

    const lengthFirst = nums1.length;
    const lengthSecond = nums2.length;

    let start = 0;
    let end = lengthFirst;

    while(start &lt;= end) {
        let part1 = Math.floor((start+end)/2);
        let part2 = Math.floor((lengthFirst + lengthSecond + 1) / 2) - part1;

        let maxLeftNum1 = part1 === 0 ? Number.MIN_SAFE_INTEGER : nums1[part1 - 1];
        let minRightNum1 = part1 === lengthFirst ? Number.MAX_SAFE_INTEGER : nums1[part1];

        let maxLeftNum2 = part2 === 0 ? Number.MIN_SAFE_INTEGER : nums2[part2 - 1];
        let minRightNum2 = part2 === lengthSecond ? Number.MAX_SAFE_INTEGER : nums2[part2];

        if(maxLeftNum1 &lt;= minRightNum2 &amp;&amp; maxLeftNum2 &lt;= minRightNum1) {
            if((lengthFirst + lengthSecond) % 2 == 0) {
                return (Math.max(maxLeftNum1, maxLeftNum2) + Math.min(minRightNum1, minRightNum2)) /2
            } else {
                return Math.max(maxLeftNum1, maxLeftNum2);
            }
        } else if(maxLeftNum1 &gt; minRightNum2) {
            end = part1 -1;
        } else {
            start = part1 +1;
        }
    }
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="memo">Memo</h1>
<pre><code class="language-typescript">export function memo(func: any) {
    const cache: any = {};
    return (...args: any[]) =&gt;{
        let key = JSON.stringify(args);
        if(cache[key]) {
            return cache[key];
        }
        const value = func.apply(null, args);
        cache[key] = value;
        return value;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="merge-sorted-array">Merge Sorted Array</h1>
<pre><code class="language-typescript">/**
 Do not return anything, modify nums1 in-place instead.
 */
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
    let j = 0;
    for(let i = 0; i &lt;= nums1.length; i++) {
        if(nums1[i] === 0 &amp;&amp; nums2[j] !== undefined) {
            nums1[i] = nums2[j];
            j++;
        }
    }
    nums1.sort((a, b) =&gt;  a - b);

};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="merge-two-sorted-linked-lists">Merge two sorted linked lists</h1>
<h2 id="solution-1">Solution 1</h2>
<pre><code class="language-typescript">function mergeLists(head1, head2) {

  let newList = new SinglyLinkedList()
  
 while (head1 &amp;&amp; head2) {
    if (head1.data &lt; head2.data) {
      newList.insertNode(head1.data)
      head1 = head1.next
    } else {
      newList.insertNode(head2.data)
      head2 = head2.next
    }
  }

  newList.tail.next = (head1) ? head1 : head2
  return newList.head;
}
</code></pre>
<h2 id="solution-2">Solution 2</h2>
<pre><code class="language-typescript">function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
    
    if(!list1) return list2;
    if(!list2) return list1;

    let head = null;
    let temp = head;

    if (list1.val &lt; list2.val) {
        temp = head = new ListNode(list1.val);
        list1 = list1.next;
    } else {
        temp = head = new ListNode(list2.val);
        list2 = list2.next;
    }

    while (list1 &amp;&amp; list2) {
        if (list1.val &lt; list2.val) {
            temp.next = new ListNode(list1.val);
            list1 = list1.next;
            temp = temp.next
        } else {
            temp.next = new ListNode(list2.val);
            list2 = list2.next;
            temp = temp.next
        }
    }
    while (list1) {
        temp.next = new ListNode(list1.val);
        list1 = list1.next;
        temp = temp.next;
    }
    while (list2) {
        temp.next = new ListNode(list2.val);
        list2 = list2.next;
        temp = temp.next;
    }
    return head;

};
</code></pre>
<p>** Source: <a href="http://hackerrank.com">http://hackerrank.com</a>**</p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="minimum-depth-of-binary-tree">Minimum Depth of Binary Tree</h1>
<pre><code class="language-typescript">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function minDepth(root: TreeNode | null): number {
        let depth = 1;
        
        if(root == null) return 0;
        let que = []
        que.push(root);
        while(que.length &gt; 0){
            let size = que.length;
            while(size&gt;0){
                let node =que.shift();

                if(node.left == null &amp;&amp; node.right == null) return depth;
                
                if(node.left != null) que.push(node.left);
                
                if(node.right != null) que.push(node.right);
                size--;
            }
            depth++;
        }
        return depth;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="missing-number">Missing number</h1>
<pre><code class="language-typescript">
function missingNumber(nums: number[]): number {
  let sum = 0;
  let expected = (1 + nums.length) * nums.length / 2;
  for (let i = 0; i &lt; nums.length; i ++) {
      sum += nums[i];
  }
  return expected - sum;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="move-zeroes">Move Zeroes</h1>
<pre><code class="language-typescript">/**
 Do not return anything, modify nums in-place instead.
 */
function moveZeroes(nums: number[]): void {
   let j = 0;
    for (let i = 0; i &lt; nums.length; i ++) {
        if (nums[i] !== 0) {
            if (i != j) {
                let tmp = nums[i];
                nums[i] = nums[j];
                nums[j] = tmp;
            }
            j++;
        }
    }
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="number-of-1-bits">Number of 1 Bits</h1>
<pre><code class="language-typescript">
function hammingWeight(n: number): number {
        let pivot = 1;
        let sum = 0;
        for (let i = 0; i &lt; 32; i ++){
            let p = pivot &lt;&lt; i;
            if ((n &amp; p) == p)
                sum ++;
        }
        return sum;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="pairs">Pairs</h1>
<pre><code class="language-typescript">function pairs(k: number, arr: number[]): number {
    arr.sort((a, b) =&gt; a-b);
    let output = 0;
    let i = 0;
    let j = 0;
    while(j &lt; arr.length) {
        let difference = arr[j] - arr[i];
        if(difference === k) {
            output++;
            j++;
            i++;
        } else if (difference &gt; k) {
            i++;
        } else if(difference &lt; k) {
            j++;
} }
    return output;
}

}
</code></pre>
<p>** Source: <a href="http://hackerrank.com">http://hackerrank.com</a>**</p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="pairwise">Pairwise</h1>
<pre><code class="language-typescript">export function pairwise(arr:number[], arg:number) {
    const index = [];

    for (let a in arr) {
        let temp = arr[a];

        for (let i = 1; i &lt; arr.length; i++) {
            let temp2 = arr[i];
            if (temp + temp2 === arg &amp;&amp; i &gt; +a &amp;&amp; index.indexOf(+a) === -1 &amp;&amp; index.indexOf(+i) === -1) {
                index.push(+a, +i);
                break;
            }
        }
    }
    if (index.length &gt;= 1) {
        const addAll = (a: any, b: any) =&gt; {
            return a + b;
        };

        return index.reduce(addAll);
    } else
        return 0;
}

let res = pairwise([1, 3, 2, 4], 4);
console.log(res);
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="palindrome-linked-list">Palindrome linked list</h1>
<pre><code class="language-typescript">
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function isPalindrome(head: ListNode | null): boolean {
    const isP = (rHead) =&gt; {
        if (rHead == null) {
            return true;
        }

        const next = isP(rHead.next);

        const valid = rHead.val === head.val;

        head = head.next;
        return next &amp;&amp; valid;
    }
    return isP(head);
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="palindrome-number">Palindrome number</h1>
<pre><code class="language-java"> class Solution {
    public boolean isPalindrome(int x) {
        if(x &lt; 0) {
            return false;
        }
        int number = x;
        int reverse = 0;
        while(number &gt; 0) {
            reverse = reverse * 10 + number % 10;
            number /= 10;
        }
        return x == reverse;
    }
}
,,,

* [Go back](../readme.md)
</code></pre>
</span></li><li><h1></h1><hr/><span><h1 id="pangram">Pangram</h1>
<pre><code class="language-typescript">function isPangram(string:string){
    const set = new Set();
    string.toLowerCase().split(&#39;&#39;).forEach((letter:string) =&gt; {
      if(/^[A-Za-z]+$/.test(letter)) {
        set.add(letter);
      }
    });
    return [...set].length === 26;
  }
,,,

* [Go back](../readme.md)
</code></pre>
</span></li><li><h1></h1><hr/><span><h1 id="pascal-triangle-2">Pascal triangle 2</h1>
<pre><code class="language-typescript">
function generate(numRows: number): number[][] {

        const pascal: any = [];

    
        for(let i = 0; i &lt; numRows; i++) {
            pascal[i] = [];
            pascal[i][0] = 1;
            for(let j = 1; j &lt; i; j++) {
                pascal[i][j] = pascal[i - 1][j - 1] + pascal[i - 1][j];
            }
            pascal[i][i] = 1;
        }

        return pascal;

};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="pascal-triangle-3">Pascal triangle 3</h1>
<pre><code class="language-typescript">function getRow(rowIndex: number): number[] {
  const res = Array(rowIndex + 1);
  res[0] = 1;
  for (let i = 1; i &lt;= rowIndex; i++) {
    res[i] = res[i - 1] * ((rowIndex - i + 1) / i);
  }
  return res;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="pascal-triangle">Pascal triangle</h1>
<pre><code class="language-java">class Solution {
    int[] pascalTriangleRow(int rowNo) {
        int pascalRow[] = new int[rowNo];
        pascalRow[0] = 1;
        rowNo--;
        for(int i = 1; i &lt;= rowNo; i++) {
            int rowElement = pascalRow[i-1] * (rowNo - i + 1) / i;
            pascalRow[i] = rowElement;
        }
        return pascalRow;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="path-sum">Path Sum</h1>
<pre><code class="language-typescript">
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function hasPathSum(root: TreeNode | null, targetSum: number): boolean {

    if(root === null) {
        return false;
    }

    if(
        root.left === null &amp;&amp;
        root.right === null &amp;&amp;
        targetSum - root.val === 0
    ) {
        return true;
    }

    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)

};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="permutations">Permutations</h1>
<pre><code class="language-typescript">function permute(nums: number[]): number[][] {
    let output = [];
    dfs(nums, 0, output);
    return output;
};


function dfs(nums, index,output) {
    if (index == nums.length){
        let l = [...nums];
        output.push(l);
    } else {
        for (let j = index; j &lt; nums.length; j++){
            let tmp = nums[index];
            nums[index] = nums[j];
            nums[j] = tmp;
            
            dfs(nums, index + 1,output);
            tmp = nums[index];
            nums[index] = nums[j];
            nums[j] = tmp;
        }
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="plus-minus">Plus minus</h1>
<pre><code class="language-typescript">function plusMinus(arr: number[]): void {
    // Write your code here
    const length = arr.length;
    let tempArr: number[] = [0, 0, 0];
    
    for(let i = 0; i &lt; length; i++) {
        if(arr[i] &gt; 0) {
            tempArr[0]++;
        } else if(arr[i] &lt; 0) {
            tempArr[1]++;
        } else {
            tempArr[2]++;
        }
    }

    console.log((tempArr[0]/length).toFixed(6));
    console.log((tempArr[1]/length).toFixed(6));
    console.log((tempArr[2]/length).toFixed(6));
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="plus-one">Plus One</h1>
<pre><code class="language-typescript">
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    let carry = 1;
    let i = digits.length - 1;

    while(i &gt;= 0 &amp;&amp; digits[i] === 9) {
        i--;
    }

    if (i == -1) {
        const result = new Array(digits.length + 1).fill(0);
        result[0] = 1;
        return result;
    }

    let result = new Array(digits.length).fill(0);
        result[i] = digits[i] + 1;
        for (let j = 0; j &lt; i; j ++) {
            result[j] = digits[j];
        }
    return result;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="power-of-two">Power of two</h1>
<pre><code class="language-typescript">function isPowerOfTwo(n: number): boolean {
    if (n &lt;= 0) {
        return false;
    }
    for (let i = 0; i &lt; 32; i ++) {
        if ((n&amp;1) == 1) {
            break;
        }
        n = n &gt;&gt;&gt; 1;
    }
    n = n &gt;&gt;&gt; 1;
    return n == 0;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="primes-upon-to-n">Primes upon to N</h1>
<pre><code class="language-java">class Solution {
    List&lt;Integer&gt; primesUptoN(int n) {
        boolean isPrime[] = new boolean[n + 1];
        ArrayList&lt;Integer&gt; output = new ArrayList&lt;Integer&gt;();
        
        for(int i = 2; i &lt;= n; i++) {
            isPrime[i] = true;
        }
            
        isPrime[0] = false;
        isPrime[1] = false;
        for(int i = 2; i * i &lt;= n; i++) {
           for(int j = i * i; j &lt;= n; j += i) {
               if(isPrime[i] == true) {
                   isPrime[j] = false;
               }
           }
       }
         for(int i = 2; i &lt;= n; i++) {
           if(isPrime[i] == true) {
               output.add(i);
           }
       }
        return output;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="promises-sequence">Promises sequence</h1>
<pre><code class="language-typescript">const a = new Promise((resolve: any, reject: any) =&gt; {
    setTimeout(() =&gt; {
        console.log(&#39;Promise a&#39;);
        resolve();
    }, 5000)
});

const b = new Promise((resolve: any, reject: any) =&gt; {
    setTimeout(() =&gt; {
        console.log(&#39;Promise b&#39;);
        resolve();
    }, 4000)
});

const c = new Promise((resolve: any, reject: any) =&gt; {
    setTimeout(() =&gt; {
        console.log(&#39;Promise c&#39;);
        resolve();
    }, 1000)
});

let q = [a,b,c].reduce((acc:any, f: any) =&gt; {
    return acc.then(() =&gt; {
        return f;
    });
}, Promise.resolve());
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="merge-two-sorted-linked-lists">Merge two sorted linked lists</h1>
<pre><code class="language-typescript">function processData(input) {
    let arr = input.split(&#39;\n&#39;);
    const stack = [];
    
    for(let i = 0; i &lt; arr.length; i++) {
        let [cmd, value] = arr[i].split(&#39; &#39;);
        if(cmd == 1) {
            stack.push(value);
        } else if(cmd == 2) {
            stack.splice(0,1);
        } else if(cmd == 3) {
            console.log(stack[0])
        }
    }
} 
,,,

** Source: http://hackerrank.com**
* [Go back](../readme.md)
</code></pre>
</span></li><li><h1></h1><hr/><span><h1 id="remove-duplicate-words">Remove duplicate words</h1>
<pre><code class="language-typescript">function removeDuplicateWords(s: string): string {
    const set = new Set();
    s.split(&#39; &#39;).forEach((str: string) =&gt; {
      set.add(str);
    });
    return [...set].join(&#39; &#39;);
  }
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="remove-duplicates">Remove duplicates</h1>
<pre><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 0) {
            return 0;
        }
        int i = 0, j = 0;
        nums[j] = nums[i];
        for(i = 1; i &lt; nums.length; i++) {
            if(nums[j] != nums[i]) {
                j = j + 1;
                nums[j] = nums[i];
            }
        }
        return j + 1;
    }
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="remove-element-in-place">Remove element in place</h1>
<pre><code class="language-typescript">function removeElement(nums: number[], val: number): number {
    let count = 0;
    for (let i = 0; i &lt; nums.length; i++) {
        if (nums[i] !== val) {
            nums[count++] = nums[i];
        }
    }
    return count;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="remove-linked-list-elements">Remove Linked List Elements</h1>
<pre><code class="language-typescript">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function removeElements(head: ListNode | null, val: number): ListNode | null {
        while (head != null &amp;&amp; head.val == val) {
            head = head.next;
        }

        if (head == null) {
            return null;
        }

        let temp = head;

        while (temp.next != null) {
            const nextNode = temp.next;
            if (nextNode.val == val) {
                temp.next = nextNode.next;
            } else {
                temp = temp.next;
            }
        }
        return head;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="reverse-array">Reverse array</h1>
<p>Solution Steps</p>
<ol>
<li>Place the two pointers (let start and end ) at the start and end of the array.</li>
<li>Swap a[start] and a[end]</li>
<li>Increment start and decrement end with 1</li>
<li>If start reached to the value length/2 or start ≥ end , then terminate otherwise repeat from step 2.</li>
</ol>
<p>Complexity Analysis</p>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
<pre><code class="language-typescript">function reverseArray(a: number[]): number[] {
    let start = 0;
    let end = a.length - 1;
    while(start &lt; end) {
        let temp = a[start];
        a[start] = a[end];
        a[end] = temp;
        start++;
        end--;
    }
    return a;
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="reverse-bits">Reverse bits</h1>
<pre><code class="language-typescript">/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
    let reversedArray = n.toString(2).split(&quot;&quot;).reverse()
    while(reversedArray.length &lt;32){ reversedArray.push(&#39;0&#39;)}
    return  parseInt(reversedArray.join(&quot;&quot;),2) 
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="reverse-string">Reverse string</h1>
<pre><code class="language-typescript">
function reverseString(s: string[]): void {
    let l = 0;
    let r = s.length - 1;

    while (l &lt; r) {
      let temp = s[l];
      s[l++] = s[r];
      s[r--] = temp;
    }
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="reverse-words">Reverse words</h1>
<p>Complete the function that accepts a string parameter, and reverses each word in the string. All spaces in the string should be retained.</p>
<p>Examples:
&quot;This is an example!&quot; ==&gt; &quot;sihT si na !elpmaxe&quot;
&quot;double  spaces&quot;      ==&gt; &quot;elbuod  secaps&quot;`;</p>
<pre><code class="language-typescript">export function reverseWords(str: string): string {
    return str.split(&#39; &#39;).map((word: string) =&gt; {
        let w = word.split(&#39;&#39;).reverse();
        return w.join(&#39;&#39;)
    }).join(&#39; &#39;);
  }
</code></pre>
<p><strong>Source: <a href="https://codewars.com">https://codewars.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="rising-temperature">Rising Temperature</h1>
<pre><code class="language-SQL"># Write your MySQL query statement below

SELECT w1.id
FROm Weather w1, Weather w2
WHERE w1.Temperature &gt; w2.Temperature
AND datediff(w1.recordDate, w2.recordDate) = 1;
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="rotate-image">Rotate image</h1>
<pre><code class="language-typescript">/**
 Do not return anything, modify matrix in-place instead.
 */
function rotate(matrix: number[][]): void {
    if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return;

    const rows = matrix.length;
    const cols = matrix[0].length;

    for(let first = 0, last = rows - 1; first &lt; last; first++, last --) {
        const tmp = matrix[first];
        matrix[first] = matrix[last];
        matrix[last] = tmp;
    }

    for(let i = 0; i &lt; rows; i++) {
        for(let j = i + 1; j &lt; cols; j++) {
            const tmp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = tmp;
        }
    }
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="same-tree">Same tree</h1>
<pre><code class="language-typescript">function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {
    if(p === null &amp;&amp; q === null) return true;

    if (p === null || q === null || p.val !== q.val){
        return false;
     }
    
    return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right, q.right);
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="search-insert-position">Search insert position</h1>
<pre><code class="language-typescript">function searchInsert(nums: number[], target: number): number {
    for(let i = 0; i &lt; nums.length; i++) {
        if(nums[i] === target) {
            return i;
        } else if(nums[i] &gt; target) {
            return i;
        }
    }
    return nums.length;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="simple-text-editor">Simple text editor</h1>
<pre><code class="language-javascript">function processData(input) {
     const [numOps, ...queries] = input.split(&#39;\n&#39;)
     const undoStack = [];
     let str = &#39;&#39;;
     
      for (let query of queries) {
        const [op, param] = query.split(&#39; &#39;)
        
        switch (op) {
            case &#39;1&#39;: 
                undoStack.push(str)
                str += param  
                break
            case &#39;2&#39;: 
                undoStack.push(str)
                str = str.substring(0, str.length - Number(param))
                break
            case &#39;3&#39;: 
                console.log(str[Number(param) - 1])
                break
            case &#39;4&#39;: 
                str = undoStack.pop()
                break
        }
    }
} 
</code></pre>
<p><strong>Source: <a href="https://hackerrank.com">https://hackerrank.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="single-number">Single Number</h1>
<pre><code class="language-typescript">/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let ans = 0;

    for(let i = 0; i &lt; nums.length; i++) {
        ans ^= nums[i];
    }

    return ans;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="sqrtx">Sqrt(x)</h1>
<pre><code class="language-typescript">/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    if(x &lt; 2) return x;

    let start = 0;
    let end = x;
    while(start &lt;= end) {
        let mid = (start + end) / 2;
        mid = Math.floor(mid);
        
        if(mid === x/mid) {
            return mid;
        }
       
       if(mid &lt; x/mid) {
           start = mid + 1;
       } else {
           end = mid - 1;
       }
    }

    if(start &gt; x/start) {
        return start - 1;
    }
    return start;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="string-to-integer-atoi">String to integer (atoi)</h1>
<pre><code class="language-typescript">/**
 * @param {string} s
 * @return {number}
 */
var myAtoi = function(s) {
    if(!s) { return 0; }

    s = s.trim();
    const INT_MAX = 2147483647;
    const INT_MIN = -2147483648;
    let i = 0;

    const isNegative = s[0] === &#39;-&#39;;
    const isPositive = s[0] === &#39;+&#39;;

    if (isNegative) {
        i++;
    } else if (isPositive) {
        i++;
    }

    let number = 0;

    while(i &lt; s.length &amp;&amp; s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;) {
        number = number * 10 + (s[i] - &#39;0&#39;);
        i++;
    }

    number = isNegative ? -number : number;

    if(number &lt; INT_MIN) {
        return INT_MIN;
    }
    if(number &gt; INT_MAX) {
        return INT_MAX;
    }
    return number;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="summary-ranges">Summary Ranges</h1>
<pre><code class="language-typescript">function summaryRanges(nums: number[]): string[] {
    const output: any[] = []

    for (let i = 0; i &lt; nums.length; ++i) {
      let begin = nums[i];
      while (i + 1 &lt; nums.length &amp;&amp; nums[i] == nums[i + 1] - 1) {
        ++i;
      }
       
      let end = nums[i];
      if (begin == end) {
        output.push(begin.toString());
      } else
        output.push(begin.toString() + &quot;-&gt;&quot; + end);
    }

    return output;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="swap-nodes-in-pairs">Swap Nodes in Pairs</h1>
<pre><code class="language-typescript">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function swapPairs(head: ListNode | null): ListNode | null {
    const dummy = new ListNode(0);

    dummy.next = head;
    let current = dummy;
    while(current.next &amp;&amp; current.next.next) {
        let first = current.next;
        let second = current.next.next;
        first.next = second.next;
        current.next = second;
        current.next.next = first;
        current = current.next.next;

    }

    return dummy.next;
};
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="symmetric-difference">Symmetric difference</h1>
<pre><code class="language-typescript">export const symmetricDifference = (...args: any) =&gt; [...new Set(args.reduce((arr1: any, arr2: any) =&gt; [
  ...arr1.filter((e: any) =&gt; !arr2.includes(e)),
  ...arr2.filter((e: any) =&gt; !arr1.includes(e))
]))];
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="symmetric-tree">Symmetric Tree</h1>
<pre><code class="language-typescript">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function isSymmetric(root: TreeNode | null): boolean {
    return root == null || isMirror(root.left, root.right); 
};

function isMirror(node1: TreeNode, node2: TreeNode): boolean {
    if(node1 === null &amp;&amp; node2 === null) return true;
    if(node1 === null || node2 === null) return false;
    if(node1.val !== node2.val) return false;

    return isMirror(node1.left, node2.right) &amp;&amp; isMirror(node1.right, node2.left);
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="tenth-line">Tenth Line</h1>
<pre><code class="language-bash"># Read from the file file.txt and output the tenth line to stdout.

head -n 10 file.txt | tail -n +10
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="time-conversion">Time conversion</h1>
<pre><code class="language-typescript">function timeConversion(s: string): string {
    const strArr = s.split(&#39;:&#39;);
    const modifier = strArr[2].slice(-2);
    let hours = strArr[0];
    if(modifier === &quot;PM&quot; &amp;&amp; strArr[0] !== &#39;12&#39;) {
        hours = +strArr[0] + 12 + &#39;&#39;;
    }
    if(modifier === &quot;AM&quot; &amp;&amp; strArr[0] === &#39;12&#39;) {
        hours = &quot;00&quot;;
    }
    return `${hours}:${strArr[1]}:${strArr[2].slice(0,-2)}`;
}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="times-function-in-js">Times function in JS</h1>
<p>Sometimes, we often find ourselves in need of running a particular function several times.</p>
<pre><code class="language-javascript">const times = (func, n) =&gt; {
  Array.from(Array(n)).forEach(() =&gt; {
    func();
  });
};

times(() =&gt; {
  randomFunction();
}, 3);
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="ugly-number">Ugly Number</h1>
<pre><code class="language-typescript">
function isUgly(n: number): boolean {
    if(n == 1) return true;
    if(n &lt;= 0) return false;
    if(n % 2 == 0) return isUgly(n / 2);
    else if(n % 3 == 0) return isUgly(n / 3);
    else if(n % 5 == 0) return isUgly(n / 5);
    else return false;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="valid-anagram">Valid Anagram</h1>
<pre><code class="language-typescript">function isAnagram(s: string, t: string): boolean {
    if(s.length !== t.length) return false;

    let hashTable = {};

    for (let i = 0; i &lt; s.length; i++) {
        if(!hashTable[s[i]]) hashTable[s[i]] = 0;
        if(!hashTable[t[i]]) hashTable[t[i]] = 0;
        hashTable[s[i]]++;
        hashTable[t[i]]--;
    }

    for(let key in hashTable){
        if(hashTable[key] != 0) return false
    }

    return true;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="valid-parentheses">Valid parentheses</h1>
<pre><code class="language-typescript">function isValid(s: string): boolean {
    const temp = [];

    for(let i = 0; i &lt; s.length; i++) {
        if(s[i] == &#39;(&#39; || s[i] == &#39;{&#39; || s[i] == &#39;[&#39;) {
            temp.push(s[i]);
        } else if(s[i] == &#39;)&#39; &amp;&amp; temp.length &amp;&amp; temp[temp.length -1 ] === &#39;(&#39;) {
            temp.pop();
        } else if(s[i] == &#39;]&#39; &amp;&amp; temp.length &amp;&amp; temp[temp.length -1 ] === &#39;[&#39;) {
            temp.pop();
        } else if(s[i] == &#39;}&#39; &amp;&amp; temp.length &amp;&amp; temp[temp.length -1 ] === &#39;{&#39;) {
            temp.pop();
        } else {
            return false;
        }
    }

    return temp.length === 0;
};
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="valid-phone-numbers">Valid Phone Numbers</h1>
<pre><code class="language-bash">
# Read from the file file.txt and output all valid phone numbers to stdout.

grep -E &quot;^(\([0-9]{3}\) |[0-9]{3}\-)[0-9]{3}\-[0-9]{4}$&quot; file.txt
</code></pre>
<p><strong>Source: <a href="https://leetcode.com">https://leetcode.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="validate-pin">Validate pin</h1>
<pre><code class="language-typescript">const validatePin = (pin: string): boolean  =&gt; {
    if(pin.length !== 4 &amp;&amp; pin.length !== 6) return false;
    return /^[0-9]{4}$|^[0-9]{6}$/gm.test(pin)
  }
</code></pre>
<p><strong>Source: <a href="https://codewars.com">https://codewars.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="word-pattern">Word Pattern</h1>
<pre><code class="language-typescript">function wordPattern(pattern: string, s: string): boolean {
    const strArr = s.split(&#39; &#39;);
    
    if ( strArr.length != pattern.length) {
        return false;
    }
    
    let hash = {};
    
    for (let i = 0; i &lt; strArr.length; i++) {
        if (hash[pattern[i]]) {
            if (hash[pattern[i]] !== strArr[i]) {
                return false;
           } 
        } else {
            if (Object.values(hash).indexOf(strArr[i]) !== -1){
                return false;
            } else {
                 hash[pattern[i]] = strArr[i];
            }
        }
    }
    
    return true;
};
</code></pre>
<p><strong>Source: <a href="https://codewars.com">https://codewars.com</a></strong></p>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li><li><h1></h1><hr/><span><h1 id="word-search">Word search</h1>
<pre><code class="language-typescript">function exist(board: string[][], word: string): boolean {
    const row = board.length;
    const col = board[0].length;
    let index = 0;
    for(let i = 0; i &lt; row; i++) {
        for(let j = 0; j&lt; col; j++){
            if(backtrack(board, word, i,j,index, row, col)) {
                return true
            }
        }
    }
    return false;
};

function backtrack(board, word, i, j,index, row, col) {
    if(index === word.length) return true;
    if(i &lt; 0 || j &lt; 0 || i === row || j === col || board[i][j] !== word[index] || board[i][j] == &#39;#&#39;) return false;

    let t = board[i][j];
    board[i][j] = &#39;#&#39;;

    let top = backtrack(board, word, i -1, j, index + 1, row, col);
    let right = backtrack(board, word, i, j + 1, index + 1, row, col);
    let bottom = backtrack(board, word, i + 1, j, index + 1, row, col);
    let left = backtrack(board, word, i, j - 1, index + 1, row, col);

    board[i][j] = t;

    return top || right || bottom || left;

}
</code></pre>
<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
</span></li></ul>