<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Holy Theory</title>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
        <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <style>
        body {
          margin: 0;
              padding: 0;
          }
  
          img {
              max-width: 400px;
          }
  
          .content {
            width: 60%;
            margin: 0 auto;
          }
        </style>
    </head>
    <body>
        <div class="content"><h1 id="ternary-search">Ternary search</h1>
<p>Ternary Search is a divide-and-conquer algorithm designed for efficiently finding the position of a target value in a sorted array. It operates by dividing the array into three parts and recursively narrowing down the search space until the target is found or determined to be absent.</p>
<h2 id="how-it-works">How it Works:</h2>
<p><strong>Step 1:</strong> Ternary Search starts by dividing the sorted array into three parts.</p>
<p><strong>Step 2:</strong> Then it compares the target value with the elements at two points within the array, dividing it into three segments. If the target is found at one of these points, the search is successful.</p>
<p><strong>Step 3:</strong> Based on the comparisons, Ternary Search identifies whether the target lies in the first, second, or third segment of the array.</p>
<p><strong>Step 4:</strong> The algorithm then recursively applies the same process to the identified segment. This recursion continues until the target is found or the search space is reduced to an empty array, indicating that the target is not present.</p>
<h2 id="key-characteristics">Key Characteristics:</h2>
<p><strong>Divide and Conquer Approach</strong>: Ternary search follows the &quot;divide and conquer&quot; paradigm. It repeatedly divides the search interval into three parts and narrows down the search space based on the value being searched for.</p>
<p><strong>Applicability</strong>: Ternary search is applicable only on sorted arrays or functions that are unimodal (i.e., having a single peak or trough). It&#39;s commonly used to find the maximum or minimum value of a unimodal function.</p>
<p><strong>Comparison Count</strong>: Ternary search reduces the size of the search space by one-third in each iteration, which means it usually performs fewer comparisons compared to binary search, especially when the desired element is closer to the ends of the array.</p>
<p><strong>Implementation</strong>: Ternary search can be implemented recursively or iteratively. The recursive implementation is straightforward and elegant, but it might suffer from stack overflow for large input sizes. The iterative implementation, on the other hand, is more efficient in terms of space.</p>
<p>// <strong>Mid-Point Calculation</strong>: In each iteration, ternary search calculates two mid-points (m1 and m2) to divide the search space into three equal parts. The value of the mid-points is calculated as follows: (m1 = \text{start} + \frac{\text{end} - \text{start}}{3}) and (m2 = \text{end} - \frac{\text{end} - \text{start}}{3}).</p>
<p><strong>Termination Condition</strong>: Ternary search terminates when the desired element is found, or the search interval becomes too small to divide further. Typically, the termination condition involves comparing the values at the two mid-points to determine which subinterval to continue searching in.</p>
<p>// <strong>Space Complexity</strong>: Ternary search has a space complexity of (O(1)) since it does not require any extra space proportional to the input size beyond a few variables used for indices and comparison values.</p>
<h2 id="applications">Applications:</h2>
<p><strong>Finding Local Extrema</strong>: Ternary search is commonly used to find the maximum or minimum value of a unimodal function over a given interval. This application arises in various fields such as optimization problems, mathematical modeling, and computer graphics.</p>
<p>// <strong>Finding a Peak in Peak Finding Problem</strong>: In a 1D peak finding problem where a peak is defined as an element greater than or equal to its neighbors, ternary search can efficiently locate a peak in (O(\log_3{n})) time complexity, where (n) is the size of the array.</p>
<p><strong>Optimizing Functions</strong>: Ternary search can be applied in optimization problems where a function needs to be optimized within a certain range. For example, in numerical methods like Newton&#39;s method or gradient descent, ternary search can help refine the search for the optimal solution.</p>
<p><strong>Searching in Sorted Arrays with Large Number of Comparisons</strong>: Ternary search can be advantageous in scenarios where the number of comparisons required for binary search becomes too high due to the nature of the data. Ternary search reduces the number of comparisons needed by approximately one-third in each iteration, potentially leading to faster search times.</p>
<p><strong>Approximate Search</strong>: Ternary search can also be adapted for approximate search tasks where finding an exact match is not necessary. For example, in databases or search engines, ternary search can efficiently narrow down the search space for approximate matches, reducing the computational cost.</p>
<p><strong>Range Queries</strong>: Ternary search can be used in range query problems where the objective is to find an element satisfying certain conditions within a range. By repeatedly dividing the search space into three parts, ternary search can efficiently locate the elements satisfying the given conditions.</p>
<p><strong>Finding Roots of Equations</strong>: Ternary search can be applied in numerical analysis to find roots of equations within a certain interval. Although methods like Newton&#39;s method are more commonly used for this purpose, ternary search can provide an alternative approach, especially when the function is not differentiable or its derivative is difficult to compute.</p>
<h2 id="time-complexity">Time Complexity:</h2>
<p>Ternary Search has a time complexity of O(log3 n), where &#39;n&#39; is the size of the array. This is an improvement over binary search when the search space can be significantly reduced at each step. However, it&#39;s worth noting that constant factors play a role, and in practice, binary search might be faster for smaller datasets due to simpler arithmetic operations. Ternary Search is particularly beneficial when the dataset is large and the search space can be significantly reduced with each iteration.</p>
<p><img src="https://raw.githubusercontent.com/AndersDeath/holy-theory/main/images/ternary-search.png" alt="Ternary search"></p>
<h2 id="example">Example</h2>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ternarySearch</span>(<span class="hljs-params">
  func: (x: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">number</span>,
  left: <span class="hljs-built_in">number</span>,
  right: <span class="hljs-built_in">number</span>,
  epsilon: <span class="hljs-built_in">number</span>
</span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">while</span> (right - left &gt; epsilon) {
    <span class="hljs-keyword">const</span> mid1 = left + (right - left) / <span class="hljs-number">3</span>;
    <span class="hljs-keyword">const</span> mid2 = right - (right - left) / <span class="hljs-number">3</span>;

    <span class="hljs-keyword">const</span> value1 = <span class="hljs-title function_">func</span>(mid1);
    <span class="hljs-keyword">const</span> value2 = <span class="hljs-title function_">func</span>(mid2);

    <span class="hljs-keyword">if</span> (value1 &lt; value2) {
      left = mid1;
    } <span class="hljs-keyword">else</span> {
      right = mid2;
    }
  }

  <span class="hljs-keyword">return</span> (left + right) / <span class="hljs-number">2</span>;
}
</code></pre></div>
    </body>
    </html>