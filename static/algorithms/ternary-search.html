<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Holy Theory</title>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
        <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <style>
        body {
          margin: 0;
              padding: 0;
          }
  
          img {
              max-width: 400px;
          }
  
          .content {
            width: 60%;
            margin: 0 auto;
          }
        </style>
    </head>
    <body>
        <div class="content"><h1 id="ternary-search">Ternary search</h1>
<p>Ternary Search is a divide-and-conquer algorithm designed for efficiently finding the position of a target value in a sorted array. It operates by dividing the array into three parts and recursively narrowing down the search space until the target is found or determined to be absent.</p>
<p><strong>How it Works:</strong></p>
<p><strong>Step 1:</strong>
Ternary Search starts by dividing the sorted array into three parts.</p>
<p><strong>Step 2:</strong>
Then it compares the target value with the elements at two points within the array, dividing it into three segments. If the target is found at one of these points, the search is successful.</p>
<p><strong>Step 3:</strong>
Based on the comparisons, Ternary Search identifies whether the target lies in the first, second, or third segment of the array.</p>
<p><strong>Step 4:</strong>
The algorithm then recursively applies the same process to the identified segment. This recursion continues until the target is found or the search space is reduced to an empty array, indicating that the target is not present.</p>
<p><strong>Key Characteristics:</strong></p>
<p><strong>Applications:</strong></p>
<p><strong>Time Complexity:</strong></p>
<p>Ternary Search has a time complexity of O(log3 n), where &#39;n&#39; is the size of the array. This is an improvement over binary search when the search space can be significantly reduced at each step. However, it&#39;s worth noting that constant factors play a role, and in practice, binary search might be faster for smaller datasets due to simpler arithmetic operations. Ternary Search is particularly beneficial when the dataset is large and the search space can be significantly reduced with each iteration.</p>
<p><img src="https://raw.githubusercontent.com/AndersDeath/holy-theory/main/images/ternary-search.png" alt="Ternary search"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ternarySearch</span>(<span class="hljs-params">
  func: (x: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">number</span>,
  left: <span class="hljs-built_in">number</span>,
  right: <span class="hljs-built_in">number</span>,
  epsilon: <span class="hljs-built_in">number</span>
</span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">while</span> (right - left &gt; epsilon) {
    <span class="hljs-keyword">const</span> mid1 = left + (right - left) / <span class="hljs-number">3</span>;
    <span class="hljs-keyword">const</span> mid2 = right - (right - left) / <span class="hljs-number">3</span>;

    <span class="hljs-keyword">const</span> value1 = <span class="hljs-title function_">func</span>(mid1);
    <span class="hljs-keyword">const</span> value2 = <span class="hljs-title function_">func</span>(mid2);

    <span class="hljs-keyword">if</span> (value1 &lt; value2) {
      left = mid1;
    } <span class="hljs-keyword">else</span> {
      right = mid2;
    }
  }

  <span class="hljs-keyword">return</span> (left + right) / <span class="hljs-number">2</span>;
}
</code></pre></div>
    </body>
    </html>