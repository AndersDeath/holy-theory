<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Holy Theory</title>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
        <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <style>
        body {
          margin: 0;
              padding: 0;
          }
  
          img {
              max-width: 400px;
          }
  
          .content {
            width: 60%;
            margin: 0 auto;
          }
        </style>
    </head>
    <body>
        <div class="content"><h1 id="interpolation-search">Interpolation search</h1>
<p>Interpolation Search is a an algorithm designed for finding a specific target value in a sorted array. Unlike linear or binary search, this algorithm utilizes the characteristics of the data distribution to make more informed decisions about where to look for the target. It is particularly effective when the data has a uniform distribution.</p>
<h2 id="how-it-works">How it works:</h2>
<p><strong>Step 1:</strong> It utilizes linear interpolation to estimate the likely position of the target value in the array.</p>
<p><strong>Step 2:</strong> Instead of evenly dividing the search space, as in binary search, the algorithm estimates the probable position of the target based on its value relative to the minimum and maximum values in the array.</p>
<p><strong>Step 3:</strong> It calculates an estimate of the target&#39;s position by considering the relative location of the target with respect to the minimum and maximum values in the current search space.</p>
<p><strong>Step 4:</strong> Based on the calculated estimate, the algorithm narrows down the search space and repeats the process until the target is found or the search space is exhausted.</p>
<h2 id="key-characteristics">Key Characteristics:</h2>
<p><strong>Estimation of Position</strong>: Interpolation search estimates the probable position of the target value within the array based on the values at the ends of the array. Unlike binary search, which always divides the search space in half, interpolation search calculates a position closer to the target based on the distribution of values in the array.</p>
<p><strong>Requirement of Sorted Array</strong>: Similar to binary search, interpolation search requires the input array to be sorted in ascending order. This is necessary to make assumptions about the distribution of values within the array and to perform efficient searches.</p>
<p><strong>Variable Step Size</strong>: In interpolation search, the step size for narrowing down the search interval varies depending on the estimated position of the target value. This variable step size allows for more efficient convergence towards the target value compared to fixed step sizes used in binary search.</p>
<p><strong>Calculation of Position</strong>: The estimated position of the target value is calculated using interpolation formula, which typically involves linear interpolation. However, other interpolation techniques such as quadratic or exponential interpolation can also be used depending on the nature of the data.</p>
<p>// <strong>Complexity</strong>: The time complexity of interpolation search is (O(\log \log n)) on average, where (n) is the number of elements in the array. This complexity is better than binary search in certain scenarios, especially when the elements are uniformly distributed.</p>
<p>// <strong>Worst-case Scenario</strong>: While interpolation search generally performs well, it can degrade to (O(n)) time complexity in the worst-case scenario, particularly when the distribution of values in the array is highly skewed or uneven.</p>
<p><strong>Handling Non-uniform Distributions</strong>: Interpolation search is particularly effective when the values in the array are uniformly distributed. However, in cases where the distribution is non-uniform, interpolation search may not provide significant advantages over other search algorithms like binary search.</p>
<p><strong>Implementation</strong>: Interpolation search can be implemented recursively or iteratively. Iterative implementation is often preferred due to its simplicity and efficiency. However, recursive implementation may be more intuitive for some programmers.</p>
<p>// <strong>Space Complexity</strong>: Interpolation search has a space complexity of (O(1)) since it does not require any additional space proportional to the input size beyond a few variables used for indices and calculations.</p>
<h2 id="applications">Applications:</h2>
<p><strong>Numerical Data Retrieval</strong>: Interpolation search is commonly used in databases and data retrieval systems where data is stored in sorted arrays. It allows for fast retrieval of numerical data, especially when the values are uniformly distributed.</p>
<p><strong>Scientific Computing</strong>: In scientific computing, the algorithm can be applied in scenarios such as searching for specific data points within large datasets or performing numerical simulations where fast access to data is crucial.</p>
<p><strong>Symbol Tables</strong>: Interpolation search can be used in symbol tables and compilers for quick retrieval of symbols or identifiers. This is particularly useful in programming languages or applications that deal with large symbol tables.</p>
<p><strong>Searching in Large Datasets</strong>: The algorithm can efficiently handle large datasets where binary search may become less efficient due to the fixed step size. It&#39;s used in applications dealing with large volumes of data such as search engines, databases, and data analytics platforms.</p>
<p><strong>Approximate Search</strong>: Interpolation search can be adapted for approximate search tasks where finding an exact match is not necessary. For example, in spell checkers or auto-complete features in text editors, interpolation search can quickly narrow down the search space for approximate matches.</p>
<p>// <strong>Time-Critical Systems</strong>: In real-time systems where response time is critical, interpolation search can be beneficial due to its average-case time complexity of (O(\log \log n)). This makes it suitable for applications requiring fast search operations, such as in financial trading systems or telecommunications networks.</p>
<p><strong>Finding Closest Values</strong>: This algorithm can be used to find the closest value to a given target value within a sorted array. This application is useful in scenarios such as image processing, signal processing, and sensor data analysis.</p>
<p><strong>Data Compression and Encoding</strong>: Interpolation search algorithms can be used in compression and encoding techniques to efficiently search for patterns or symbols within compressed data streams. This is common in multimedia compression algorithms like JPEG and MPEG.</p>
<p><strong>Geospatial Data Processing</strong>: In geographic information systems (GIS) and mapping applications, interpolation search can be used to quickly retrieve spatial data points or locations based on their coordinates, enabling efficient spatial analysis and visualization.</p>
<p><strong>Machine Learning and Data Mining</strong>: Interpolation search can be applied in machine learning algorithms and data mining tasks for efficient searching and retrieval of data points during training or querying processes, especially in high-dimensional spaces.</p>
<h2 id="time-complexity">Time Complexity:</h2>
<p>The time complexity of Interpolation Search is O(log log n) on average, where &quot;n&quot; is the number of elements in the array. In the best case, it can be O(1), and in the worst case, it can be O(n). However, the average case is often more relevant, and it is O(log log n) under certain assumptions about the distribution of the data.</p>
<p><img src="https://raw.githubusercontent.com/AndersDeath/holy-theory/main/images/interpolation-search.png" alt="Interpolation search"></p>
<h2 id="example">Example</h2>
<!-- ignore start -->

<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpolationSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> value)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span>(value &gt;=array[low] &amp;&amp; value &lt;= array[high] &amp;&amp; low &lt;= high) {
            <span class="hljs-type">int</span> <span class="hljs-variable">probe</span> <span class="hljs-operator">=</span> low + (high - low) * (value - array[low]) / (array[high] - array[low]);
            <span class="hljs-keyword">if</span>(array[probe] == value) {
                <span class="hljs-keyword">return</span> probe;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[probe] &gt; value) {
                low = probe + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                high = probe -<span class="hljs-number">1</span>;
            }

        }

        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

}
</code></pre><!-- ignore end -->

<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">interpolationSearch</span>(<span class="hljs-params">array: <span class="hljs-built_in">number</span>[], value: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> high = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (value &gt;= array[low] &amp;&amp; value &lt;= array[high] &amp;&amp; low &lt;= high) {
    <span class="hljs-keyword">const</span> probe =
      low + ((high - low) * (value - array[low])) / (array[high] - array[low]);
    <span class="hljs-keyword">const</span> roundedProbe = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(probe);

    <span class="hljs-keyword">if</span> (array[roundedProbe] === value) {
      <span class="hljs-keyword">return</span> roundedProbe;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[roundedProbe] &lt; value) {
      low = roundedProbe + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      high = roundedProbe - <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre></div>
    </body>
    </html>