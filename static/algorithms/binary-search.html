<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Holy Theory</title>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
        <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <style>
        body {
          margin: 0;
              padding: 0;
          }
  
          img {
              max-width: 400px;
          }
  
          .content {
            width: 60%;
            margin: 0 auto;
          }
        </style>
    </head>
    <body>
        <div class="content"><h1 id="binary-search">Binary search</h1>
<p>Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted,.</p>
<h2 id="how-it-works">How it works:</h2>
<p><strong>Step 1:</strong> Read the search element from the user.</p>
<p><strong>Step 2:</strong> Find the middle element in the sorted list.</p>
<p><strong>Step 3:</strong> Compare the search element with the middle element in the sorted list.</p>
<p><strong>Step 4:</strong> If both are matched, then display &quot;Given element is found!!!&quot; and terminate the function.</p>
<p><strong>Step 5:</strong> If both are not matched, then check whether the search element is smaller or larger than the middle element.</p>
<p><strong>Step 6:</strong> If the search element is smaller than middle element, repeat steps 2, 3, 4 and 5 for the left sublist of the middle element.</p>
<p><strong>Step 7:</strong> If the search element is larger than middle element, repeat steps 2, 3, 4 and 5 for the right sublist of the middle element.</p>
<p><strong>Step 8:</strong> Repeat the same process until we find the search element in the list or until sublist contains only one element.</p>
<p><strong>Step 9:</strong> If that element also doesn&#39;t match with the search element, then returns -1;</p>
<h2 id="key-characteristics">Key Characteristics:</h2>
<p><strong>Divide and Conquer Approach</strong>: Binary search follows the principle of &quot;divide and conquer.&quot; It repeatedly divides the search interval in half until the target element is found or the interval is empty.</p>
<p><strong>Efficiency</strong>: Binary search is highly efficient, particularly for large datasets, because it eliminates half of the remaining elements in each step. It has a time complexity of O(log n), where n is the number of elements in the array.</p>
<p><strong>Requirement of Sorted Data</strong>: Binary search requires the data to be sorted beforehand. This ensures that the algorithm can reliably make decisions about which half of the array to search in.</p>
<p><strong>Iterative or Recursive Implementation</strong>: Binary search can be implemented either iteratively or recursively. Both approaches follow the same logic but differ in their implementation details.</p>
<p><strong>Midpoint Calculation</strong>: In each iteration, binary search calculates the midpoint of the search interval to determine whether the target element lies in the left or right half of the interval.</p>
<p><strong>Termination Condition</strong>: Binary search terminates when the search interval is empty, indicating that the target element is not present in the array, or when the target element is found.</p>
<p><strong>Space Complexity</strong>: Binary search has a space complexity of O(1), meaning it requires constant extra space for storing variables regardless of the size of the input array.</p>
<p><strong>Works on Random Access Data Structures</strong>: Binary search is ideal for arrays or other data structures that allow random access to elements, such as arrays or certain types of lists.</p>
<p><strong>Efficient for Large Datasets</strong>: Due to its logarithmic time complexity, binary search performs well even on large datasets, making it a preferred choice for many searching applications.</p>
<p><strong>Not Suitable for Unsorted Data</strong>: Since binary search relies on the sorted nature of the data, it&#39;s not suitable for unsorted arrays or lists. Pre-sorting the data is a prerequisite for using binary search effectively.</p>
<h2 id="applications">Applications:</h2>
<p><strong>Searching in Databases</strong>: Binary search is widely used in databases for fast retrieval of records based on keys. Databases often use sorted indexes to enable binary search, which significantly reduces the time required to locate specific records.</p>
<p><strong>Searching in Trees and Graphs</strong>: Binary search is employed in various tree-based and graph-based data structures like binary search trees, AVL trees, and red-black trees for efficient searching and retrieval of elements.</p>
<p><strong>Sorting Algorithms</strong>: Binary search is utilized in sorting algorithms such as quicksort and mergesort to efficiently partition and merge elements. Although these sorting algorithms primarily rely on divide-and-conquer techniques, binary search plays a crucial role in the process.</p>
<p><strong>Finding Median and Percentile</strong>: Binary search is used to find the median or percentile in a sorted array or list. By repeatedly narrowing down the search range, binary search efficiently locates the desired element, providing quick statistical analysis capabilities.</p>
<p><strong>Searching in Texts</strong>: Binary search can be applied in text processing applications for tasks such as searching for keywords or phrases in sorted text files or dictionaries. This is particularly useful in applications like spell checkers or autocomplete features.</p>
<p><strong>Network Routing</strong>: Binary search is utilized in network routing algorithms to efficiently locate routes in routing tables. By organizing routing information in sorted structures, binary search can quickly identify the optimal path for data packets in computer networks.</p>
<p><strong>Approximate Matching and Fuzzy Searching</strong>: Binary search can be adapted for approximate matching or fuzzy searching applications where exact matches are not required. By defining appropriate search criteria and tolerances, binary search can efficiently locate approximate matches in sorted datasets.</p>
<p><strong>Genetics and Bioinformatics</strong>: Binary search is used in various bioinformatics applications for tasks such as searching for specific DNA sequences or analyzing genomic data. Its efficiency makes it valuable for processing large volumes of genetic information.</p>
<p><strong>Game Development</strong>: Binary search is employed in various game development scenarios, such as pathfinding algorithms or determining optimal strategies. For example, in certain types of games, binary search can be used to efficiently locate targets or identify the best course of action.</p>
<p><strong>Resource Allocation</strong>: Binary search can be applied in resource allocation problems, such as scheduling tasks or managing inventory. By efficiently searching for available resources or optimal scheduling slots, binary search helps optimize resource utilization and allocation.</p>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>Worst case: O(log n)</li>
<li>Average case: O(log n)</li>
<li>Best case: O(1)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/AndersDeath/holy-theory/main/images/binary-search.png" alt="Binary search"></p>
<h2 id="example">Example:</h2>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span> = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">mid</span>: <span class="hljs-built_in">number</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (nums[mid] === target) <span class="hljs-keyword">return</span> mid;
    <span class="hljs-keyword">if</span> (target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;
  }

  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre><!-- ignore start -->

<pre><code class="hljs language-java">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> {

        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span>(low &lt;= high) {
            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;
            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> array[middle];

            <span class="hljs-keyword">if</span>(value &lt; target) {
                low = middle + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value &gt; target) {
                high = middle - <span class="hljs-number">1</span>;

            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> middle;
            }
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}
</code></pre><pre><code class="hljs language-python">
<span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params"><span class="hljs-built_in">list</span>, item</span>):
    low = <span class="hljs-number">0</span>
    high = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>) - <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> low &lt;= high:
        mid = (low+high)/<span class="hljs-number">2</span>
        guess = <span class="hljs-built_in">list</span>[mid]
        <span class="hljs-keyword">if</span> guess == item:
            <span class="hljs-keyword">return</span> mid
        <span class="hljs-keyword">if</span> guess &gt; item:
            high = mid - <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            low = mid +<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]

res = binary_search(my_list, <span class="hljs-number">3</span>)

<span class="hljs-built_in">print</span>(my_list[res])
</code></pre><!-- ignore end -->
</div>
    </body>
    </html>