<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Holy Theory</title>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
        <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <style>
        body {
          margin: 0;
              padding: 0;
          }
  
          img {
              max-width: 400px;
          }
  
          .content {
            width: 60%;
            margin: 0 auto;
          }
        </style>
    </head>
    <body>
        <div class="content"><h1 id="merge-sort">Merge sort</h1>
<p>Merge Sort is a comparison-based sorting algorithm that follows the divide-and-conquer paradigm. It works by dividing the unsorted array into &#39;n&#39; sub-arrays, each containing one element. It then repeatedly merges these sub-arrays to produce new sorted sub-arrays until there is only one sub-array remaining - the fully sorted array.</p>
<h2 id="how-it-works">How it works:</h2>
<p><strong>Step 1:</strong> Divide - The unsorted array is recursively divided into two halves until each sub-array contains only one element. This is the base case of the recursion.</p>
<p><strong>Step 2:</strong> Conquer - The adjacent sub-arrays are then recursively merged to produce new sorted sub-arrays. This process continues until there is only one sub-array remaining the fully sorted array.</p>
<p><strong>Step 3:</strong> Merge - The key operation in Merge Sort is the merging of two sorted sub-arrays to produce a single, sorted sub-array. This involves comparing elements from the two sub-arrays and placing them in the correct order.</p>
<h2 id="key-characteristics">Key Characteristics:</h2>
<p><strong>Divide and Conquer</strong>: Merge Sort is a divide-and-conquer algorithm that breaks down the array into smaller sub-arrays, sorts each sub-array recursively, and then merges them to obtain a sorted array.</p>
<p><strong>Stable Sorting</strong>: It is a stable sorting algorithm, meaning that it preserves the relative order of equal elements during sorting.</p>
<p><strong>Efficient for Large Datasets</strong>: This efficient time complexity makes it well-suited for sorting large datasets, outperforming many other sorting algorithms for such scenarios.</p>
<p><strong>In-place vs. Out-of-place</strong>: While Merge Sort can be implemented both in-place (where it sorts the array within its original memory space) and out-of-place (where it requires additional memory space), the out-of-place implementation is more common due to its simplicity and efficiency.</p>
<p><strong>Parallelizability</strong>: The algorithm can be parallelized easily, allowing it to take advantage of multiple processors or threads for faster sorting of data.</p>
<p><strong>Space Complexity</strong>: Merge Sort typically has a space complexity of O(n), as it requires additional memory space for the temporary arrays used during the merging process.</p>
<p><strong>Reliable Performance</strong>: Merge Sort&#39;s consistent time complexity and stable sorting make it a reliable choice for applications where predictable performance and stability are essential.</p>
<h2 id="applications">Applications:</h2>
<p><strong>Sorting Large Datasets</strong>: Merge Sort is highly efficient for sorting large datasets, making it suitable for various applications where sorting a significant amount of data is required. This includes tasks like sorting database records, organizing files on disk, or processing large sets of data in scientific research.</p>
<p><strong>External Sorting</strong>: It is commonly used in external sorting algorithms where data is too large to fit into memory entirely. It efficiently sorts data stored on external storage devices like hard drives by dividing it into manageable chunks, sorting them in memory, and then merging them back together.</p>
<p><strong>Network Routing</strong>: The algorithm is utilized in network routing algorithms for organizing and sorting routing tables efficiently. In networking applications, sorting large sets of routing information is crucial for optimizing data transmission and network performance.</p>
<p><strong>Parallel Processing</strong>: Its divide-and-conquer approach lends itself well to parallel processing. It can be parallelized across multiple processors or threads, allowing for faster sorting of data in parallel computing environments.</p>
<p><strong>Optimizing Data Processing Pipelines</strong>: Merge Sort can be used in data processing pipelines to efficiently sort and merge streams of data from different sources. This is common in real-time data analytics, where sorted data is essential for performing efficient queries and analyses.</p>
<p><strong>Operating Systems</strong>: It is employed in various components of operating systems for tasks like sorting file directories, managing memory allocation, and organizing system resources efficiently.</p>
<h2 id="time-complexity">Time Complexity:</h2>
<p>Merge Sort has a consistent time complexity of O(n log n) in all cases, where &#39;n&#39; is the number of elements in the array. It is a stable sorting algorithm, meaning that equal elements maintain their relative order in the sorted output. While Merge Sort has a slightly higher space complexity due to the need for additional memory, its stability and predictable performance make it a widely used and reliable sorting algorithm.</p>
<p><img src="https://raw.githubusercontent.com/AndersDeath/holy-theory/main/images/merge-sort.png" alt="Merge sort"></p>
<h2 id="example">Example:</h2>
<!-- ignore start -->

<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">subArr1Size</span> <span class="hljs-operator">=</span> mid - low + <span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">subArr2Size</span> <span class="hljs-operator">=</span> high - mid;

        <span class="hljs-type">int</span> [] subArr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[subArr1Size];
        <span class="hljs-type">int</span> [] subArr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[subArr2Size];

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subArr1Size; i++) {
           subArr1[i] = arr[low + i];
           }
           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subArr2Size; i++) {
           subArr2[i] = arr[mid + <span class="hljs-number">1</span> + i];
        }
        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = low;

        <span class="hljs-keyword">while</span>(i &lt; subArr1Size &amp;&amp; j &lt; subArr2Size) {
            <span class="hljs-keyword">if</span>(subArr1[i] &lt;= subArr2[j]) {
                arr[k] = subArr1[i];
                i++;
            } <span class="hljs-keyword">else</span> {
                arr[k] = subArr2[j];
                j++;
            }
            k++;
        }
        <span class="hljs-keyword">while</span>(i &lt; subArr1Size) {
            arr[k++] = subArr1[i++];
        }
        <span class="hljs-keyword">while</span> (j &lt; subArr2Size) {
           arr[k++] = subArr2[j++];
       }
    }

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span>{
        <span class="hljs-keyword">if</span>(high &gt; low) {
            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (high + low) / <span class="hljs-number">2</span>;
            mergesort(arr, low, mid);
            mergesort(arr, mid + <span class="hljs-number">1</span>, high);
            merge(arr, low, mid, high);
        }
    }

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;
        mergesort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);
    }
}
</code></pre><!-- ignore end -->

<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[] {
  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> arr;
  }

  <span class="hljs-keyword">const</span> middle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);
  <span class="hljs-keyword">const</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle);
  <span class="hljs-keyword">const</span> right = arr.<span class="hljs-title function_">slice</span>(middle);

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left: <span class="hljs-built_in">number</span>[], right: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[] {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];
  <span class="hljs-keyword">let</span> leftIndex = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> rightIndex = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span> (leftIndex &lt; left.<span class="hljs-property">length</span> &amp;&amp; rightIndex &lt; right.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) {
      result.<span class="hljs-title function_">push</span>(left[leftIndex]);
      leftIndex++;
    } <span class="hljs-keyword">else</span> {
      result.<span class="hljs-title function_">push</span>(right[rightIndex]);
      rightIndex++;
    }
  }

  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">concat</span>(left.<span class="hljs-title function_">slice</span>(leftIndex)).<span class="hljs-title function_">concat</span>(right.<span class="hljs-title function_">slice</span>(rightIndex));
}
</code></pre></div>
    </body>
    </html>