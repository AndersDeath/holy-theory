<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Holy Theory</title>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
        <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <style>
        body {
          margin: 0;
              padding: 0;
          }
  
          img {
              max-width: 400px;
          }
  
          .content {
            width: 60%;
            margin: 0 auto;
          }
        </style>
    </head>
    <body>
        <div class="content"><h1 id="interval-search">Interval search</h1>
<p>An interval search algorithm typically refers to searching for overlapping or containing intervals in a collection of intervals. One common approach for this task is to use an interval tree. Here&#39;s an explanation of the Interval Search algorithm using an interval tree:</p>
<p><strong>How Interval Search Works:</strong></p>
<ol>
<li><p><strong>Construct the Interval Tree:</strong></p>
<ul>
<li>Begin by constructing an interval tree from the given set of intervals.</li>
<li>Each node in the interval tree represents an interval, and the tree is recursively built to efficiently organize and store these intervals.</li>
</ul>
</li>
<li><p><strong>Search for Overlapping Intervals:</strong></p>
<ul>
<li>When searching for intervals that overlap with a given interval (query interval), start at the root of the interval tree.</li>
</ul>
</li>
<li><p><strong>Traverse the Tree:</strong></p>
<ul>
<li>Traverse the tree, comparing the query interval with the intervals represented by each node.</li>
<li>If there is an overlap, the algorithm can either return the overlapping interval(s) immediately or continue searching in both left and right subtrees.</li>
</ul>
</li>
<li><p><strong>Recursive Search:</strong></p>
<ul>
<li>Recursively search in the left or right subtree based on the relationship between the query interval and the intervals represented by the current node.</li>
<li>Continue this process until all potential overlapping intervals are found.</li>
</ul>
</li>
</ol>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>The time complexity of searching for overlapping intervals using an interval tree is typically O(log n + k), where &#39;n&#39; is the number of intervals in the tree and &#39;k&#39; is the number of intervals overlapping with the query interval. The construction of the interval tree initially takes O(n log n) time, but subsequent searches are more efficient. Interval trees are particularly useful when there are many queries for overlapping intervals in a set.</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Interval</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];

<span class="hljs-keyword">function</span> <span class="hljs-title function_">intervalSearch</span>(<span class="hljs-params">
  intervals: Interval[],
  queryInterval: Interval
</span>): <span class="hljs-built_in">number</span>[] {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; intervals.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> [start, end] = intervals[i];
    <span class="hljs-keyword">const</span> [queryStart, queryEnd] = queryInterval;

    <span class="hljs-keyword">if</span> (start &lt;= queryEnd &amp;&amp; end &gt;= queryStart) {
      result.<span class="hljs-title function_">push</span>(i);
    }
  }

  <span class="hljs-keyword">return</span> result;
}
</code></pre></div>
    </body>
    </html>