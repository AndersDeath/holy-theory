<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Holy Theory</title>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
        <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <style>
        body {
          margin: 0;
              padding: 0;
          }
  
          img {
              max-width: 400px;
          }
  
          .content {
            width: 60%;
            margin: 0 auto;
          }
        </style>
    </head>
    <body>
        <div class="content"><h1 id="insertion-sort">Insertion sort</h1>
<p>Insertion Sort is a straightforward sorting algorithm that builds the sorted array one element at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, it has some advantages: it is simple to implement, efficient for small datasets, and performs well for partially sorted arrays.</p>
<h2 id="how-it-works">How it works:</h2>
<p><strong>Step 1:</strong> Consider the first element to be a sorted subarray and the rest as an unsorted subarray</p>
<p><strong>Step 2:</strong> Sequentially iterate over the unsorted elements of the array and move them to the sorted subarray.</p>
<p><strong>Step 3:</strong> For each unsorted element, compare the current element with the elements before it</p>
<p><strong>Step 4:</strong> If the current element is greater than its preceding one, leave it there, as it is already at the desired position. If not, keep comparing it with the elements before it until a smaller or equal one is found: Insert the current element after and all comparisons are made, and no smaller one is found: Insert the current item at the beginning of the array</p>
<p><strong>Step 5:</strong> Repeat the above process for every element of the unsorted subarray until the array is sorted</p>
<h2 id="key-characteristics">Key Characteristics:</h2>
<p><strong>Basic Algorithm</strong>: Insertion sort builds the final sorted array one element at a time, by repeatedly taking the next element from the unsorted part and inserting it into its correct position in the sorted part.</p>
<p><strong>In-place Sorting</strong>: It sorts elements by moving them within the array, without requiring additional storage space.</p>
<p><strong>Stable</strong>: It is a stable sorting algorithm, meaning that it preserves the relative order of equal elements.</p>
<p><strong>Adaptive</strong>: Insertion sort is adaptive to some extent. If the input list is almost sorted, it can perform better than its worst-case time complexity.</p>
<p><strong>Efficient for Small Datasets</strong>: It is efficient for sorting small datasets or arrays, particularly when the array is nearly sorted.</p>
<p><strong>Simple Implementation</strong>: It is straightforward to implement and understand, making it a good choice for educational purposes or for sorting small lists.</p>
<p><strong>Efficient for Nearly Sorted Data</strong>: The algorithm performs well on data that is already partially sorted, as it only requires shifting a few elements to insert a new one.</p>
<h2 id="applications">Applications:</h2>
<p><strong>Small Datasets</strong>: Insertion sort is suitable for sorting small datasets efficiently due to its simplicity and low overhead.</p>
<p><strong>Nearly Sorted Data</strong>: It performs well on data that is already partially sorted, requiring minimal adjustments to insert new elements.</p>
<p><strong>Online Algorithms</strong>: It can be useful in situations where data is continuously arriving, as it can efficiently incorporate new elements into a sorted list.</p>
<p><strong>Embedded Systems</strong>: Due to its simple implementation and low memory requirements, Insertion sort is suitable for sorting small arrays in resource-constrained environments, such as embedded systems.</p>
<p><strong>Educational Purposes</strong>: It is often used as a teaching tool to introduce sorting algorithms due to its straightforward implementation and understanding.</p>
<p><strong>Stable Sorting</strong>: Insertion sort&#39;s stability makes it suitable for applications where preserving the relative order of equal elements is necessary.</p>
<p><strong>Auxiliary Sorting Algorithm</strong>: It can be used as a building block within more complex sorting algorithms or algorithms requiring a partially sorted list.</p>
<p><strong>Time Complexity:</strong></p>
<p>Insertion Sort has a time complexity of O(n^2) in the worst case, where &#39;n&#39; is the number of elements in the array. Despite its quadratic time complexity, the algorithm is often more efficient on small datasets or partially sorted arrays compared to other quadratic sorting algorithms. It&#39;s also an in-place sorting algorithm, meaning it doesn&#39;t require additional memory.</p>
<p><img src="https://raw.githubusercontent.com/AndersDeath/holy-theory/main/images/insertion-sort.png" alt="Insertion sort"></p>
<h2 id="example">Example</h2>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">array: <span class="hljs-built_in">number</span>[] | <span class="hljs-built_in">string</span>[]</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">let</span> curr = array[i];
    <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (j; j &gt;= <span class="hljs-number">0</span> &amp;&amp; array[j] &gt; curr; j--) {
      array[j + <span class="hljs-number">1</span>] = array[j];
    }
    array[j + <span class="hljs-number">1</span>] = curr;
  }
  <span class="hljs-keyword">return</span> array;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">insertionSort</span>([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">345</span>, <span class="hljs-number">123</span>, <span class="hljs-number">43</span>, <span class="hljs-number">32</span>]));
</code></pre><!-- ignore start -->

<pre><code class="hljs language-java">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
        <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {
            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) {
                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i];
                <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span>(position &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[position] &gt; current) {
                    arr[position + <span class="hljs-number">1</span>] = arr[position];
                    position--;
                }
                arr[position + <span class="hljs-number">1</span>] = current;
            }
        }
    }
</code></pre><!-- ignore end -->
</div>
    </body>
    </html>