<!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Holy Theory</title>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
      <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
      <style>
      body {
        margin: 0;
            padding: 0;
        }

        img {
            max-width: 400px;
        }

        .content {
          width: 60%;
          margin: 0 auto;
        }
      </style>
  </head>
  <body>
      <div class="content"><h1 id="jump-search">Jump search</h1>
<p>Jump Search is a searching algorithm designed for sorted arrays. It is a block-based search algorithm that works by jumping ahead by fixed steps and then linearly searching within the block for the target element. Jump Search combines the efficiency of binary search with the simplicity of linear search.</p>
<p><strong>How Jump Search Works:</strong></p>
<ol>
<li><p><strong>Determine Jump Size:</strong></p>
<ul>
<li>Determine the jump size by taking the square root of the array length. This ensures a balanced trade-off between the number of jumps and the linear search within a block.</li>
</ul>
</li>
<li><p><strong>Jump Ahead:</strong></p>
<ul>
<li>Start at the beginning of the array and jump ahead by the calculated jump size until finding a value that is greater than or equal to the target.</li>
</ul>
</li>
<li><p><strong>Linear Search within Block:</strong></p>
<ul>
<li>Perform a linear search within the block from the previous jump until finding the target element or determining that it is not present in the block.</li>
</ul>
</li>
<li><p><strong>Repeat or Conclude:</strong></p>
<ul>
<li>Repeat the process until the entire array is searched or the target element is found.</li>
</ul>
</li>
</ol>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><p><strong>Efficiency:</strong></p>
<ul>
<li>Jump Search has a time complexity of -add formula-, making it more efficient than linear search -add formula-, and comparable to binary search -add formula- for large datasets.</li>
</ul>
</li>
<li><p><strong>Sorted Arrays:</strong></p>
<ul>
<li>Jump Search requires the array to be sorted.</li>
</ul>
</li>
<li><p><strong>Jump Size:</strong></p>
<ul>
<li>The jump size is a critical factor in the efficiency of Jump Search. The optimal jump size is often calculated as the square root of the array length.</li>
</ul>
</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li><p><strong>Database Searching:</strong></p>
<ul>
<li>Jump Search is used in database systems for searching in large datasets.</li>
</ul>
</li>
<li><p><strong>Sorted Arrays:</strong></p>
<ul>
<li>Useful when the data is sorted, and random access to elements is feasible.</li>
</ul>
</li>
</ul>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>The time complexity of Jump Search is -add formula-,, where-add formula-, is the size of the array. This makes it efficient for large datasets when compared to linear search but may be outperformed by binary search for certain scenarios.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/AndersDeath/holy-theory/main/images/jump-search.png" alt="Jump search"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jumpSearch</span>(<span class="hljs-params">arr: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> step = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n));
  <span class="hljs-keyword">let</span> prev = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span> (arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(step, n) - <span class="hljs-number">1</span>] &lt; target) {
    prev = step;
    step += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n));
    <span class="hljs-keyword">if</span> (prev &gt;= n) {
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = prev; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(step, n); i++) {
    <span class="hljs-keyword">if</span> (arr[i] === target) {
      <span class="hljs-keyword">return</span> i;
    }
  }

  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre></div>
  </body>
  </html>