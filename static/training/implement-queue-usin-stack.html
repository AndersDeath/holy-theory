<!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Holy Theory</title>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
      <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
      <style>
      body {
        margin: 0;
            padding: 0;
        }

        img {
            max-width: 400px;
        }

        .content {
          width: 60%;
          margin: 0 auto;
        }
      </style>
  </head>
  <body>
      <div class="content"><h1 id="implement-queue-using-stacks">Implement Queue using Stacks</h1>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> {
    <span class="hljs-attr">stack1</span>: <span class="hljs-built_in">number</span>[] = [];
    <span class="hljs-attr">stack2</span>: <span class="hljs-built_in">number</span>[] = [];

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

    <span class="hljs-title function_">push</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-title function_">push</span>(x);
    }

    <span class="hljs-title function_">pop</span>(): <span class="hljs-built_in">number</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">move</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-title function_">pop</span>();
    }

    <span class="hljs-title function_">peek</span>(): <span class="hljs-built_in">number</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">move</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
    }

    <span class="hljs-title function_">empty</span>(): <span class="hljs-built_in">boolean</span> {
        <span class="hljs-keyword">return</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-property">length</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-property">length</span>;
    }

    <span class="hljs-title function_">move</span>(): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-property">length</span>) {
            <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-property">length</span>) {
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-title function_">pop</span>());
            }
        }
    }
}

<span class="hljs-comment">/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */</span>
</code></pre><p>The code is a TypeScript implementation of a queue data structure using two stacks. It defines a class <code>MyQueue</code> with various queue operations implemented using two stacks, <code>stack1</code> and <code>stack2</code>.</p>
<p>Here&#39;s a step-by-step explanation of the code:</p>
<ol>
<li><p>The class <code>MyQueue</code> is defined, which represents a queue data structure.</p>
</li>
<li><p>The constructor function is defined, but it doesn&#39;t do anything since the stacks (<code>stack1</code> and <code>stack2</code>) are already initialized as empty arrays.</p>
</li>
<li><p>The <code>push</code> method allows adding an element to the queue. It simply pushes the element onto <code>stack1</code>, which acts as the back of the queue.</p>
</li>
<li><p>The <code>pop</code> method removes and returns the front element from the queue. It first calls the <code>move</code> method to transfer elements from <code>stack1</code> to <code>stack2</code>, ensuring that the order of elements is reversed (first-in, first-out). Then, it pops the last element from <code>stack2</code>, which is the front of the queue.</p>
</li>
<li><p>The <code>peek</code> method returns the front element of the queue without removing it. Similar to <code>pop</code>, it also calls the <code>move</code> method to transfer elements from <code>stack1</code> to <code>stack2</code>, and then returns the last element of <code>stack2</code>.</p>
</li>
<li><p>The <code>empty</code> method checks if the queue is empty. It returns <code>true</code> if both <code>stack1</code> and <code>stack2</code> are empty, indicating that the queue has no elements.</p>
</li>
<li><p>The <code>move</code> method is a private helper function used to transfer elements from <code>stack1</code> to <code>stack2</code>. It is called by <code>pop</code> and <code>peek</code> methods when needed. The purpose of this method is to maintain the correct order of elements in the queue, allowing efficient front element retrieval.</p>
</li>
</ol>
<p>Techniques used in this code include:</p>
<ul>
<li>Implementing a queue using two stacks to efficiently perform queue operations (enqueue, dequeue, and peek).</li>
<li>Utilizing the LIFO (Last-In-First-Out) property of stacks to reverse the order of elements when moving them from <code>stack1</code> to <code>stack2</code>.</li>
<li>Ensuring that elements are moved to <code>stack2</code> only when necessary (on calls to <code>pop</code> and <code>peek</code>) to avoid unnecessary element transfers.</li>
</ul>
</div>
  </body>
  </html>