<!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Holy Theory</title>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
      <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
      <style>
      body {
        margin: 0;
            padding: 0;
        }

        img {
            max-width: 400px;
        }

        .content {
          width: 60%;
          margin: 0 auto;
        }
      </style>
  </head>
  <body>
      <div class="content"><h1 id="linked-list-cycle">Linked List Cycle</h1>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">ListNode</span>} <span class="hljs-variable">head</span>
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">boolean</span>}
 */</span>
<span class="hljs-keyword">var</span> hasCycle = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) {

    <span class="hljs-keyword">let</span> slowNode = head;
    <span class="hljs-keyword">let</span> fastNode = head;

    <span class="hljs-keyword">while</span>(fastNode !== <span class="hljs-literal">null</span> &amp;&amp; fastNode.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {
        fastNode = fastNode.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
        slowNode = slowNode.<span class="hljs-property">next</span>;

        <span class="hljs-keyword">if</span>(fastNode === slowNode) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};
</code></pre><p>The code is a JavaScript function that determines whether a singly-linked list has a cycle (a loop) or not. It uses the &quot;tortoise and hare&quot; approach, also known as Floyd&#39;s Cycle Detection Algorithm, to detect cycles in a linked list.</p>
<p>Here&#39;s a step-by-step explanation of the code:</p>
<ol>
<li><p>The <code>hasCycle</code> function takes a single parameter <code>head</code>, which represents the head of the linked list.</p>
</li>
<li><p>It initializes two pointers: <code>slowNode</code> and <code>fastNode</code>, both pointing to the <code>head</code> of the linked list.</p>
</li>
<li><p>It enters a <code>while</code> loop that continues as long as <code>fastNode</code> is not <code>null</code> and <code>fastNode.next</code> is not <code>null</code>. This condition ensures that the fast pointer can make a valid move without encountering a null reference.</p>
</li>
<li><p>Inside the loop:</p>
<ul>
<li>The <code>fastNode</code> pointer moves two steps ahead by accessing its <code>.next.next</code> reference. This simulates the &quot;hare&quot; moving faster in the linked list.</li>
<li>The <code>slowNode</code> pointer moves one step ahead by accessing its <code>.next</code> reference. This simulates the &quot;tortoise&quot; moving slower in the linked list.</li>
</ul>
</li>
<li><p>After each iteration of the loop, the code checks whether the <code>fastNode</code> and <code>slowNode</code> pointers are pointing to the same node. If they are, it means a cycle has been detected, and the function returns <code>true</code>.</p>
</li>
<li><p>If the loop completes without finding a cycle, the function returns <code>false</code>.</p>
</li>
</ol>
<p>The technique used in this code is the &quot;tortoise and hare&quot; algorithm for cycle detection in linked lists. This algorithm is based on the idea that if there is a cycle in the linked list, the fast and slow pointers will eventually meet at some point within the cycle. If there is no cycle, the fast pointer will reach the end of the list without encountering a null reference.</p>
<p>Overall, this algorithm has a time complexity of O(n), where n is the number of nodes in the linked list, and a space complexity of O(1), as it only uses a constant amount of extra space for the two pointers.</p>
</div>
  </body>
  </html>