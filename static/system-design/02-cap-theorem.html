<!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Holy Theory</title>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css" />
      <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
      <style>
      body {
        margin: 0;
            padding: 0;
        }

        img {
            max-width: 400px;
        }

        .content {
          width: 60%;
          margin: 0 auto;
        }
      </style>
  </head>
  <body>
      <div class="content"><h2 id="cap-theorem">CAP theorem</h2>
<p>CAP theorem, also known as Brewer&#39;s theorem, has become a fundamental principle in the design and operation of distributed systems. Let&#39;s delve deeper into each aspect of the theorem and explore real-world examples and implications.</p>
<h3 id="1-consistency">1. <strong>Consistency:</strong></h3>
<p>Consistency in the context of CAP theorem means that all nodes in a distributed system have the same data at any given point in time. Ensuring consistency often involves coordination and synchronization between nodes. Strongly consistent systems guarantee that once a piece of data is written, all subsequent reads will return that value.</p>
<ul>
<li><strong>Example:</strong> Traditional relational databases (like MySQL, PostgreSQL) often prioritize consistency. When a transaction is committed, the database ensures that the changes are immediately visible to all subsequent queries.</li>
</ul>
<h3 id="2-availability">2. <strong>Availability:</strong></h3>
<p>Availability refers to the ability of the system to respond to every request, without any downtime. Highly available systems remain operational and responsive, even in the face of failures.</p>
<ul>
<li><strong>Example:</strong> NoSQL databases like Cassandra and Couchbase emphasize availability. They are designed to operate without interruption even if some of their nodes fail, ensuring that the service is always accessible.</li>
</ul>
<h3 id="3-partition-tolerance">3. <strong>Partition Tolerance:</strong></h3>
<p>Partition tolerance means that the system continues to function even if network partitions occur, i.e., if communication between nodes is unreliable or slow. Partition tolerance is crucial for distributed systems because network failures are inevitable in real-world scenarios.</p>
<ul>
<li><strong>Example:</strong> Distributed systems like Hadoop and Apache Kafka prioritize partition tolerance. They are built to handle network partitions and communication delays between nodes, ensuring the system&#39;s stability under adverse network conditions.</li>
</ul>
<h3 id="real-world-scenarios-and-trade-offs">Real-World Scenarios and Trade-Offs:</h3>
<ul>
<li><p><strong>RDBMS (Relational Database Management Systems):</strong> Traditional SQL databases are typically designed for consistency and availability. They sacrifice partition tolerance to ensure data integrity and accuracy. This means that in the event of a network partition, these systems might not be fully operational.</p>
</li>
<li><p><strong>NoSQL Databases (Cassandra, Couchbase, MongoDB, Redis):</strong> NoSQL databases often choose to sacrifice consistency under certain conditions to achieve high availability and partition tolerance. They provide eventual consistency, meaning that given enough time, all nodes in the system will converge to a consistent state, but immediate consistency might be compromised.</p>
</li>
<li><p><strong>NewSQL Databases:</strong> Some modern databases like Google Spanner and CockroachDB attempt to provide a balance between consistency, availability, and partition tolerance. They use innovative techniques like synchronized clocks and distributed transactions to achieve global consistency while maintaining high availability and partition tolerance.</p>
</li>
</ul>
<h3 id="considerations-for-system-architects">Considerations for System Architects:</h3>
<ol>
<li><p><strong>Understanding Requirements:</strong> Architects need to assess the specific needs of their applications. Some applications, like banking systems, require strict consistency, while others, like social media platforms, can tolerate eventual consistency.</p>
</li>
<li><p><strong>Tuning for Trade-Offs:</strong> Architects often need to make trade-offs based on the CAP theorem. For instance, during network partitions, architects might choose to sacrifice consistency temporarily to maintain system availability.</p>
</li>
<li><p><strong>Hybrid Approaches:</strong> In many real-world scenarios, hybrid approaches are adopted. Different parts of the system might prioritize different aspects of the CAP theorem based on their requirements. For example, a system might use a consistent database for financial transactions while employing an eventually consistent database for non-critical data.</p>
</li>
</ol>
<p>In summary, the CAP theorem provides a valuable framework for understanding the inherent trade-offs in distributed systems. Architects and developers must carefully consider these trade-offs based on the specific requirements and use cases of their applications.</p>
<p><img src="https://raw.githubusercontent.com/AndersDeath/holy-theory/main/images/02-cap-theorem.png" alt="CAP theorem"></p>
</div>
  </body>
  </html>