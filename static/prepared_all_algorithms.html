<p style="page-break-after: always;"> </p><h1 id="bubble-sort">Bubble sort</h1>
<p>Bubble sorting is one of the simplest sorting algorithms that is not used in practice, but is actively used for training purposes. It works by repeatedly going through the sorted list, comparing each pair of neighboring elements and replacing them if they are in the wrong order. The pass through the list is repeated until no permutations are needed, indicating that the list is sorted.</p>
<p><strong>How it works:</strong></p>
<ol>
<li><p><strong>Comparing neighboring elements:</strong></p>
<ul>
<li>The algorithm starts by comparing the first two elements of the array. If the first element is greater than the second, they are swapped. Otherwise, they remain in their positions.</li>
</ul>
</li>
<li><p><strong>Iterative process:</strong></p>
<ul>
<li>This process is then repeated for each pair of neighboring elements throughout the array. After the first iteration, the largest element will &quot;pop up&quot; to the last position.</li>
</ul>
</li>
<li><p><strong>Next passes:</strong></p>
<ul>
<li>The algorithm then repeats the process for the remaining elements (excluding those already sorted at the end of the array). At each pass, the next largest element is placed in the correct position.</li>
</ul>
</li>
<li><p><strong>Termination:</strong></p>
<ul>
<li>The algorithm terminates when a pass through the entire array is made without any swaps, indicating that the array is now sorted.</li>
</ul>
</li>
</ol>
<p><strong>Time complexity:</strong> - Bubble sort has a time complexity of O(n^2) in the worst and average cases, where n is the number of elements in the array. This makes it inefficient for large datasets but useful for educational purposes because of its simplicity.</p>
<p><img src="images/bubble-sort.png" alt="Bubble sort"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">array: <span class="hljs-built_in">number</span>[] | <span class="hljs-built_in">string</span>[]</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i; j++) {
      <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) {
        [array[j], array[j + <span class="hljs-number">1</span>]] = [array[j + <span class="hljs-number">1</span>], array[j]];
      }
    }
  }
  <span class="hljs-keyword">return</span> array;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bubbleSort</span>([<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">22</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));
</code></pre><!-- ignore start -->

<pre><code class="hljs language-java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> {
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length - i - <span class="hljs-number">1</span>; j++) {
                <span class="hljs-keyword">if</span>(array[j] &gt; array[j + <span class="hljs-number">1</span>]) {
                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j];
                    array[j] = array[j + <span class="hljs-number">1</span>];
                    array[j + <span class="hljs-number">1</span>] = temp;
                }
            }
        }
    }
</code></pre><!-- ignore end -->

<ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
<p style="page-break-after: always;"> </p><h1 id="selection-sort">Selection sort</h1>
<p><img src="images/selection-sort.png" alt="Selection sort"></p>
<p>Selection Sort is a straightforward sorting algorithm that works by dividing the input array into two parts: the sorted and the unsorted subarrays. The algorithm repeatedly selects the minimum (or maximum, depending on the sorting order) element from the unsorted subarray and swaps it with the first unsorted element. This process is iteratively applied until the entire array is sorted.</p>
<p><strong>How Selection Sort Works:</strong></p>
<ol>
<li><p><strong>Dividing the Array:</strong></p>
<ul>
<li>The algorithm starts with the entire array considered as unsorted.</li>
</ul>
</li>
<li><p><strong>Finding the Minimum Element:</strong></p>
<ul>
<li>In each iteration, Selection Sort finds the minimum element from the unsorted part of the array.</li>
</ul>
</li>
<li><p><strong>Swapping:</strong></p>
<ul>
<li>Once the minimum element is identified, it is swapped with the first element in the unsorted part, effectively extending the sorted subarray.</li>
</ul>
</li>
<li><p><strong>Iterative Process:</strong></p>
<ul>
<li>The above steps are repeated for the remaining unsorted part of the array until the entire array is sorted.</li>
</ul>
</li>
</ol>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-params">array: <span class="hljs-built_in">any</span>[]</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
    <span class="hljs-keyword">let</span> min = i;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; array.<span class="hljs-property">length</span>; j++) {
      <span class="hljs-keyword">if</span> (array[min] &gt; array[j]) min = j;
    }
    [array[i], array[min]] =[array[min], array[i]]
  }
  <span class="hljs-keyword">return</span> array;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">selectionSort</span>([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">345</span>, <span class="hljs-number">123</span>, <span class="hljs-number">43</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5643</span>, <span class="hljs-number">63</span>, <span class="hljs-number">123</span>, <span class="hljs-number">43</span>, <span class="hljs-number">2</span>, <span class="hljs-number">55</span>, <span class="hljs-number">1</span>, <span class="hljs-number">234</span>, <span class="hljs-number">92</span>]));
</code></pre><!-- ignore start -->

<pre><code class="hljs language-java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> {
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> i;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; array.length; j++) {
                <span class="hljs-keyword">if</span>(array[min] &gt; array[j]) {
                    min = j;
                }
            }
            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];
            array[i] = array[min];
            array[min] = temp;
        }
    }
</code></pre><pre><code class="hljs language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This is selection sort&#x27;</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_smallest</span>(<span class="hljs-params">arr</span>):
    smallest = arr[<span class="hljs-number">0</span>]
    smallest_index = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr)):
        <span class="hljs-keyword">if</span> arr[i] &lt; smallest:
            smallest = arr[i]
            smallest_index = i
    <span class="hljs-keyword">return</span> smallest_index

<span class="hljs-keyword">def</span> <span class="hljs-title function_">selection_sort</span>(<span class="hljs-params">arr</span>):
    newArr = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):
        smallest = find_smallest(arr)
        newArr.append(arr.pop(smallest))
    <span class="hljs-keyword">return</span> newArr

<span class="hljs-built_in">print</span>(selection_sort([<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">123</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">23</span> ,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,]))
</code></pre><!-- ignore end -->

<p style="page-break-after: always;"> </p><h1 id="insertion-sort">Insertion sort</h1>
<p>Insertion Sort is a straightforward sorting algorithm that builds the sorted array one element at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, it has some advantages: it is simple to implement, efficient for small datasets, and performs well for partially sorted arrays.</p>
<p><strong>How Insertion Sort Works:</strong></p>
<ol>
<li><p><strong>Dividing the Array:</strong></p>
<ul>
<li>The algorithm starts with the first element of the array considered as the sorted part.</li>
</ul>
</li>
<li><p><strong>Inserting Elements:</strong></p>
<ul>
<li>For each element in the unsorted part of the array, Insertion Sort compares it with the elements in the sorted part.</li>
<li>It then inserts the element into its correct position in the sorted part, shifting the other elements if necessary.</li>
</ul>
</li>
<li><p><strong>Iterative Process:</strong></p>
<ul>
<li>This process is repeated until all elements are sorted.</li>
</ul>
</li>
</ol>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>Insertion Sort has a time complexity of O(n^2) in the worst case, where &#39;n&#39; is the number of elements in the array. Despite its quadratic time complexity, Insertion Sort is often more efficient on small datasets or partially sorted arrays compared to other quadratic sorting algorithms. It&#39;s also an in-place sorting algorithm, meaning it doesn&#39;t require additional memory.</li>
</ul>
<p><img src="images/insertion-sort.png" alt="Insertion sort"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">array: <span class="hljs-built_in">number</span>[] | <span class="hljs-built_in">string</span>[]</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">let</span> curr = array[i];
        <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (j; j &gt;= <span class="hljs-number">0</span> &amp;&amp; array[j] &gt; curr; j--) {
            array[j + <span class="hljs-number">1</span>] = array[j];
        }
        array[j + <span class="hljs-number">1</span>] = curr;
    }
    <span class="hljs-keyword">return</span> array;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">insertionSort</span>([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">345</span>, <span class="hljs-number">123</span>, <span class="hljs-number">43</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5643</span>, <span class="hljs-number">63</span>, <span class="hljs-number">123</span>, <span class="hljs-number">43</span>, <span class="hljs-number">2</span>, <span class="hljs-number">55</span>, <span class="hljs-number">1</span>, <span class="hljs-number">234</span>, <span class="hljs-number">92</span>]));
</code></pre><!-- ignore start -->

<pre><code class="hljs language-java">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
        <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {
            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) {
                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i];
                <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span>(position &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[position] &gt; current) {
                    arr[position + <span class="hljs-number">1</span>] = arr[position];
                    position--;
                }
                arr[position + <span class="hljs-number">1</span>] = current;
            }
        }
    }
</code></pre><!-- ignore end -->
<p style="page-break-after: always;"> </p><h1 id="quicksort">Quicksort</h1>
<p>Quick Sort is an efficient, comparison-based sorting algorithm that follows the divide-and-conquer paradigm. It works by selecting a &quot;pivot&quot; element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted.</p>
<p><strong>How Quick Sort Works:</strong></p>
<ol>
<li><p><strong>Choosing a Pivot:</strong></p>
<ul>
<li>The algorithm selects a pivot element from the array. The choice of pivot can affect the efficiency of the algorithm.</li>
</ul>
</li>
<li><p><strong>Partitioning:</strong></p>
<ul>
<li>Elements smaller than the pivot are moved to its left, and elements greater than the pivot are moved to its right. The pivot is now in its final sorted position.</li>
</ul>
</li>
<li><p><strong>Recursive Sorting:</strong></p>
<ul>
<li>The algorithm is applied recursively to the sub-arrays on the left and right of the pivot until the entire array is sorted.</li>
</ul>
</li>
</ol>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>Quick Sort has an average and best-case time complexity of O(n log n), where &#39;n&#39; is the number of elements in the array. In the worst case, it is O(n^2), but this is rare when a good pivot selection strategy is used. Quick Sort is often faster in practice than other O(n log n) algorithms, and it is widely used in various applications due to its efficiency.</li>
</ul>
<p><img src="images/quick-sort.png" alt="Quick sort"></p>
<!-- ignore start -->

<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {

    <span class="hljs-type">int</span> <span class="hljs-title function_">makePartition</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[high];
        <span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> low - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low; i &lt; high; i++) {
            <span class="hljs-keyword">if</span>(arr[i] &lt; pivot) {
                currentIndex++;
                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];
                arr[i] = arr[currentIndex];
                arr[currentIndex] = temp;
            }

        }
        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[high];
        arr[high] = arr[currentIndex + <span class="hljs-number">1</span>];
        arr[currentIndex + <span class="hljs-number">1</span>] = temp;
        <span class="hljs-keyword">return</span> currentIndex + <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> {
        <span class="hljs-keyword">if</span>(low &lt; high) {
            <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> makePartition(arr, low, high);
            quicksort(arr, low, pivot - <span class="hljs-number">1</span>);
            quicksort(arr, pivot + <span class="hljs-number">1</span>, high);
        }
    }

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;
        quicksort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);
    }
}
</code></pre><pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quicksort</span>(<span class="hljs-params">arr</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> arr
    <span class="hljs-keyword">else</span>:
        pivot = arr[<span class="hljs-built_in">len</span>(arr)/<span class="hljs-number">2</span>]
        less = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt;= pivot]
        greater = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &gt; pivot]
        <span class="hljs-keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)

<span class="hljs-built_in">print</span>(quicksort([<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]))
</code></pre><pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {
        <span class="hljs-keyword">if</span>(end &lt;= start) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// base case</span>

        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> partition(array, start, end);

        quickSort(array, start, pivot -<span class="hljs-number">1</span>);
        quickSort(array, pivot + <span class="hljs-number">1</span>, end);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> array[end];

        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> start; j &lt;= end -<span class="hljs-number">1</span>; j++) {
            <span class="hljs-keyword">if</span>(array[j] &lt; pivot) {
                i++;
                swap(array, i, j);
            }
        }
        i++;
        swap(array, i, end);

        <span class="hljs-keyword">return</span> i;
    }
}
</code></pre><!-- ignore end -->

<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quicksort</span>(<span class="hljs-params">arr: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[] {
  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> arr;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> pivot = arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)];
    <span class="hljs-keyword">const</span> less = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i &lt;= pivot);
    <span class="hljs-keyword">const</span> greater = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i &gt; pivot);
    <span class="hljs-keyword">return</span> [...<span class="hljs-title function_">quicksort</span>(less), pivot, ...<span class="hljs-title function_">quicksort</span>(greater)];
  }
}
</code></pre><ul>
<li><a href="../readme.md">Go back</a></li>
</ul>
<p style="page-break-after: always;"> </p><h1 id="merge-sort">Merge sort</h1>
<p>Merge Sort is a comparison-based sorting algorithm that follows the divide-and-conquer paradigm. It works by dividing the unsorted array into &#39;n&#39; sub-arrays, each containing one element. It then repeatedly merges these sub-arrays to produce new sorted sub-arrays until there is only one sub-array remaining – the fully sorted array.</p>
<p><strong>How Merge Sort Works:</strong></p>
<ol>
<li><p><strong>Divide:</strong></p>
<ul>
<li>The unsorted array is recursively divided into two halves until each sub-array contains only one element. This is the base case of the recursion.</li>
</ul>
</li>
<li><p><strong>Conquer:</strong></p>
<ul>
<li>The adjacent sub-arrays are then recursively merged to produce new sorted sub-arrays. This process continues until there is only one sub-array remaining – the fully sorted array.</li>
</ul>
</li>
<li><p><strong>Merge:</strong></p>
<ul>
<li>The key operation in Merge Sort is the merging of two sorted sub-arrays to produce a single, sorted sub-array. This involves comparing elements from the two sub-arrays and placing them in the correct order.</li>
</ul>
</li>
</ol>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>Merge Sort has a consistent time complexity of O(n log n) in all cases, where &#39;n&#39; is the number of elements in the array. It is a stable sorting algorithm, meaning that equal elements maintain their relative order in the sorted output. While Merge Sort has a slightly higher space complexity due to the need for additional memory, its stability and predictable performance make it a widely used and reliable sorting algorithm.</li>
</ul>
<p><img src="images/merge-sort.png" alt="Merge sort"></p>
<!-- ignore start -->

<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">subArr1Size</span> <span class="hljs-operator">=</span> mid - low + <span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">subArr2Size</span> <span class="hljs-operator">=</span> high - mid;

        <span class="hljs-type">int</span> [] subArr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[subArr1Size];
        <span class="hljs-type">int</span> [] subArr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[subArr2Size];

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subArr1Size; i++) {
           subArr1[i] = arr[low + i];
           }
           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subArr2Size; i++) {
           subArr2[i] = arr[mid + <span class="hljs-number">1</span> + i];
        }
        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = low;

        <span class="hljs-keyword">while</span>(i &lt; subArr1Size &amp;&amp; j &lt; subArr2Size) {
            <span class="hljs-keyword">if</span>(subArr1[i] &lt;= subArr2[j]) {
                arr[k] = subArr1[i];
                i++;
            } <span class="hljs-keyword">else</span> {
                arr[k] = subArr2[j];
                j++;
            }
            k++;
        }
        <span class="hljs-keyword">while</span>(i &lt; subArr1Size) {
            arr[k++] = subArr1[i++];
        }
        <span class="hljs-keyword">while</span> (j &lt; subArr2Size) {
           arr[k++] = subArr2[j++];
       }
    }

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span>{
        <span class="hljs-keyword">if</span>(high &gt; low) {
            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (high + low) / <span class="hljs-number">2</span>;
            mergesort(arr, low, mid);
            mergesort(arr, mid + <span class="hljs-number">1</span>, high);
            merge(arr, low, mid, high);
        }
    }

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;
        mergesort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);
    }
}
</code></pre><!-- ignore end -->

<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[] {
  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> arr;
  }

  <span class="hljs-keyword">const</span> middle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);
  <span class="hljs-keyword">const</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle);
  <span class="hljs-keyword">const</span> right = arr.<span class="hljs-title function_">slice</span>(middle);

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left: <span class="hljs-built_in">number</span>[], right: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[] {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];
  <span class="hljs-keyword">let</span> leftIndex = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> rightIndex = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span> (leftIndex &lt; left.<span class="hljs-property">length</span> &amp;&amp; rightIndex &lt; right.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) {
      result.<span class="hljs-title function_">push</span>(left[leftIndex]);
      leftIndex++;
    } <span class="hljs-keyword">else</span> {
      result.<span class="hljs-title function_">push</span>(right[rightIndex]);
      rightIndex++;
    }
  }

  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">concat</span>(left.<span class="hljs-title function_">slice</span>(leftIndex)).<span class="hljs-title function_">concat</span>(right.<span class="hljs-title function_">slice</span>(rightIndex));
}
</code></pre><p style="page-break-after: always;"> </p><h1 id="linear-search">Linear search</h1>
<p>Linear Search, also known as sequential search, is a simple searching algorithm that finds the position of a target value within a list or array. It works by iterating through the elements one by one until the target value is found or the entire list has been searched.</p>
<p><strong>How Linear Search Works:</strong></p>
<ol>
<li><p><strong>Start at the Beginning:</strong></p>
<ul>
<li>Linear Search begins by looking at the first element in the list.</li>
</ul>
</li>
<li><p><strong>Compare with Target:</strong></p>
<ul>
<li>It compares the current element with the target value that we are searching for.</li>
</ul>
</li>
<li><p><strong>Search Iteratively:</strong></p>
<ul>
<li>If the current element is equal to the target value, the search is successful, and the index or position of the element is returned.</li>
<li>If the current element is not equal to the target value, the search continues by moving to the next element in the list.</li>
<li>This process is repeated until either the target value is found or the end of the list is reached.</li>
</ul>
</li>
</ol>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of Linear Search is O(n), where &#39;n&#39; is the number of elements in the array. In the worst case, the algorithm may need to iterate through the entire list to find the target value. While Linear Search is simple, it may not be the most efficient for large datasets, especially when compared to more advanced search algorithms like binary search on sorted lists. However, it is easy to understand and implement.</p>
<p><img src="images/linear-search.png" alt="Linear search"></p>
<pre><code class="hljs language-typescript">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">linearSearch</span>(<span class="hljs-params">arr: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">if</span> (arr[i] === target) {
      <span class="hljs-keyword">return</span> i; 
    }
  }

  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre><p style="page-break-after: always;"> </p><h1 id="jump-search">Jump search</h1>
<p>Jump Search is a searching algorithm designed for sorted arrays. It is a block-based search algorithm that works by jumping ahead by fixed steps and then linearly searching within the block for the target element. Jump Search combines the efficiency of binary search with the simplicity of linear search.</p>
<p><strong>How Jump Search Works:</strong></p>
<ol>
<li><p><strong>Determine Jump Size:</strong></p>
<ul>
<li>Determine the jump size by taking the square root of the array length. This ensures a balanced trade-off between the number of jumps and the linear search within a block.</li>
</ul>
</li>
<li><p><strong>Jump Ahead:</strong></p>
<ul>
<li>Start at the beginning of the array and jump ahead by the calculated jump size until finding a value that is greater than or equal to the target.</li>
</ul>
</li>
<li><p><strong>Linear Search within Block:</strong></p>
<ul>
<li>Perform a linear search within the block from the previous jump until finding the target element or determining that it is not present in the block.</li>
</ul>
</li>
<li><p><strong>Repeat or Conclude:</strong></p>
<ul>
<li>Repeat the process until the entire array is searched or the target element is found.</li>
</ul>
</li>
</ol>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><p><strong>Efficiency:</strong></p>
<ul>
<li>Jump Search has a time complexity of -add formula-, making it more efficient than linear search -add formula-, and comparable to binary search -add formula- for large datasets.</li>
</ul>
</li>
<li><p><strong>Sorted Arrays:</strong></p>
<ul>
<li>Jump Search requires the array to be sorted.</li>
</ul>
</li>
<li><p><strong>Jump Size:</strong></p>
<ul>
<li>The jump size is a critical factor in the efficiency of Jump Search. The optimal jump size is often calculated as the square root of the array length.</li>
</ul>
</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li><p><strong>Database Searching:</strong></p>
<ul>
<li>Jump Search is used in database systems for searching in large datasets.</li>
</ul>
</li>
<li><p><strong>Sorted Arrays:</strong></p>
<ul>
<li>Useful when the data is sorted, and random access to elements is feasible.</li>
</ul>
</li>
</ul>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>The time complexity of Jump Search is -add formula-,, where-add formula-, is the size of the array. This makes it efficient for large datasets when compared to linear search but may be outperformed by binary search for certain scenarios.</li>
</ul>
<p><img src="images/jump-search.png" alt="Jump search"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jumpSearch</span>(<span class="hljs-params">arr: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> step = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n));
  <span class="hljs-keyword">let</span> prev = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span> (arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(step, n) - <span class="hljs-number">1</span>] &lt; target) {
    prev = step;
    step += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n));
    <span class="hljs-keyword">if</span> (prev &gt;= n) {
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = prev; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(step, n); i++) {
    <span class="hljs-keyword">if</span> (arr[i] === target) {
      <span class="hljs-keyword">return</span> i;
    }
  }

  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre><p style="page-break-after: always;"> </p><h1 id="binary-search">Binary search</h1>
<p><img src="images/binary-search.png" alt="Binary search"></p>
<p><strong>Steps:</strong></p>
<ul>
<li>Step 1 - Read the search element from the user.</li>
<li>Step 2 - Find the middle element in the sorted list.</li>
<li>Step 3 - Compare the search element with the middle element in the sorted list.</li>
<li>Step 4 - If both are matched, then display &quot;Given element is found!!!&quot; and terminate the function.</li>
<li>Step 5 - If both are not matched, then check whether the search element is smaller or larger than the middle element.</li>
<li>Step 6 - If the search element is smaller than middle element, repeat steps 2, 3, 4 and 5 for the left sublist of the middle element.</li>
<li>Step 7 - If the search element is larger than middle element, repeat steps 2, 3, 4 and 5 for the right sublist of the middle element.</li>
<li>Step 8 - Repeat the same process until we find the search element in the list or until sublist contains only one element.</li>
<li>Step 9 - If that element also doesn&#39;t match with the search element, then returns -1;</li>
</ul>
<hr>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>Worst case: O(log n)</li>
<li>Average case: O(log n)</li>
<li>Best case: O(1)</li>
</ul>
<pre><code class="hljs language-typescript">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span> = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">mid</span>: <span class="hljs-built_in">number</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (nums[mid] === target) <span class="hljs-keyword">return</span> mid;
    <span class="hljs-keyword">if</span> (target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;
  }

  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre><!-- ignore start -->

<pre><code class="hljs language-java">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> {
        
        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;
        
        <span class="hljs-keyword">while</span>(low &lt;= high) {
            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;
            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> array[middle];
            
            <span class="hljs-keyword">if</span>(value &lt; target) {
                low = middle + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value &gt; target) {
                high = middle - <span class="hljs-number">1</span>;
                
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> middle;
            }
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}
</code></pre><pre><code class="hljs language-python">
<span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params"><span class="hljs-built_in">list</span>, item</span>):
    low = <span class="hljs-number">0</span>
    high = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>) - <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> low &lt;= high:
        mid = (low+high)/<span class="hljs-number">2</span>
        guess = <span class="hljs-built_in">list</span>[mid]
        <span class="hljs-keyword">if</span> guess == item:
            <span class="hljs-keyword">return</span> mid
        <span class="hljs-keyword">if</span> guess &gt; item:
            high = mid - <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            low = mid +<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]

res = binary_search(my_list, <span class="hljs-number">3</span>)

<span class="hljs-built_in">print</span>(my_list[res])
</code></pre><!-- ignore end -->
<p style="page-break-after: always;"> </p><h1 id="ternary-search">Ternary search</h1>
<p>Ternary Search is a divide-and-conquer algorithm designed for efficiently finding the position of a target value in a sorted array. It operates by dividing the array into three parts and recursively narrowing down the search space until the target is found or determined to be absent.</p>
<p><strong>How Ternary Search Works:</strong></p>
<ol>
<li><p><strong>Divide the Array:</strong></p>
<ul>
<li>Ternary Search starts by dividing the sorted array into three parts.</li>
</ul>
</li>
<li><p><strong>Compare with the Target:</strong></p>
<ul>
<li>It then compares the target value with the elements at two points within the array, dividing it into three segments.</li>
<li>If the target is found at one of these points, the search is successful.</li>
</ul>
</li>
<li><p><strong>Determine Search Space:</strong></p>
<ul>
<li>Based on the comparisons, Ternary Search identifies whether the target lies in the first, second, or third segment of the array.</li>
</ul>
</li>
<li><p><strong>Recursive Search:</strong></p>
<ul>
<li>The algorithm then recursively applies the same process to the identified segment.</li>
<li>This recursion continues until the target is found or the search space is reduced to an empty array, indicating that the target is not present.</li>
</ul>
</li>
</ol>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>Ternary Search has a time complexity of O(log3 n), where &#39;n&#39; is the size of the array. This is an improvement over binary search when the search space can be significantly reduced at each step. However, it&#39;s worth noting that constant factors play a role, and in practice, binary search might be faster for smaller datasets due to simpler arithmetic operations. Ternary Search is particularly beneficial when the dataset is large and the search space can be significantly reduced with each iteration.</li>
</ul>
<p><img src="images/ternary-search.png" alt="Ternary search"></p>
<pre><code class="hljs language-typescript">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ternarySearch</span>(<span class="hljs-params">func: (x: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">number</span>, left: <span class="hljs-built_in">number</span>, right: <span class="hljs-built_in">number</span>, epsilon: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">while</span> (right - left &gt; epsilon) {
    <span class="hljs-keyword">const</span> mid1 = left + (right - left) / <span class="hljs-number">3</span>;
    <span class="hljs-keyword">const</span> mid2 = right - (right - left) / <span class="hljs-number">3</span>;

    <span class="hljs-keyword">const</span> value1 = <span class="hljs-title function_">func</span>(mid1);
    <span class="hljs-keyword">const</span> value2 = <span class="hljs-title function_">func</span>(mid2);

    <span class="hljs-keyword">if</span> (value1 &lt; value2) {
      left = mid1;
    } <span class="hljs-keyword">else</span> {
      right = mid2;
    }
  }

  <span class="hljs-keyword">return</span> (left + right) / <span class="hljs-number">2</span>;
}
</code></pre><p style="page-break-after: always;"> </p><h1 id="interpolation-search">Interpolation search</h1>
<p>Interpolation Search is a an algorithm designed for finding a specific target value in a sorted array. Unlike linear or binary search, this algorithm utilizes the characteristics of the data distribution to make more informed decisions about where to look for the target. It is particularly effective when the data has a uniform distribution.</p>
<p><strong>How Interpolation Search Works:</strong></p>
<ol>
<li><p><strong>Linear Interpolation:</strong></p>
<ul>
<li>Interpolation Search utilizes linear interpolation to estimate the likely position of the target value in the array.</li>
</ul>
</li>
<li><p><strong>Estimate Position:</strong></p>
<ul>
<li>Instead of evenly dividing the search space, as in binary search, Interpolation Search estimates the probable position of the target based on its value relative to the minimum and maximum values in the array.</li>
</ul>
</li>
<li><p><strong>Calculation of Position:</strong></p>
<ul>
<li>It calculates an estimate of the target&#39;s position by considering the relative location of the target with respect to the minimum and maximum values in the current search space.</li>
</ul>
</li>
<li><p><strong>Refine Search:</strong></p>
<ul>
<li>Based on the calculated estimate, the algorithm narrows down the search space and repeats the process until the target is found or the search space is exhausted.</li>
</ul>
</li>
</ol>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of Interpolation Search is O(log log n) on average, where &quot;n&quot; is the number of elements in the array. In the best case, it can be O(1), and in the worst case, it can be O(n). However, the average case is often more relevant, and it is O(log log n) under certain assumptions about the distribution of the data.</p>
<p><img src="images/interpolation-search.png" alt="Interpolation search"></p>
<!-- ignore start -->

<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpolationSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> value)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span>(value &gt;=array[low] &amp;&amp; value &lt;= array[high] &amp;&amp; low &lt;= high) {
            <span class="hljs-type">int</span> <span class="hljs-variable">probe</span> <span class="hljs-operator">=</span> low + (high - low) * (value - array[low]) / (array[high] - array[low]);
            <span class="hljs-keyword">if</span>(array[probe] == value) {
                <span class="hljs-keyword">return</span> probe;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[probe] &gt; value) {
                low = probe + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                high = probe -<span class="hljs-number">1</span>;
            }

        }

        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

}
</code></pre><!-- ignore end -->

<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">interpolationSearch</span>(<span class="hljs-params">array: <span class="hljs-built_in">number</span>[], value: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> high = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (value &gt;= array[low] &amp;&amp; value &lt;= array[high] &amp;&amp; low &lt;= high) {
    <span class="hljs-keyword">const</span> probe =
      low + ((high - low) * (value - array[low])) / (array[high] - array[low]);
    <span class="hljs-keyword">const</span> roundedProbe = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(probe);

    <span class="hljs-keyword">if</span> (array[roundedProbe] === value) {
      <span class="hljs-keyword">return</span> roundedProbe;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[roundedProbe] &lt; value) {
      low = roundedProbe + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      high = roundedProbe - <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre><p style="page-break-after: always;"> </p><h1 id="breadth-first-search">Breadth-first search</h1>
<p>Breadth-First Search (BFS) is a graph traversal algorithm that systematically explores all the vertices of a graph in breadthward motion, level by level. It starts at a chosen vertex and visits all its neighbors before moving on to their neighbors. BFS is commonly used to find the shortest path in an unweighted graph and to explore the structure of a graph.</p>
<p><strong>How Breadth-First Search Works:</strong></p>
<ol>
<li><p><strong>Queue Initialization:</strong></p>
<ul>
<li>Begin by selecting a starting vertex and enqueue it into a queue.</li>
</ul>
</li>
<li><p><strong>Explore Neighbors:</strong></p>
<ul>
<li>Dequeue a vertex from the front of the queue and explore all its neighbors.</li>
<li>Enqueue any unvisited neighbors, marking them as visited to avoid duplication.</li>
</ul>
</li>
<li><p><strong>Level-wise Exploration:</strong></p>
<ul>
<li>Continue the process level by level, exploring all vertices at the current level before moving on to the next level.</li>
</ul>
</li>
<li><p><strong>Termination:</strong></p>
<ul>
<li>Repeat until the queue is empty, ensuring that all reachable vertices are visited.</li>
</ul>
</li>
</ol>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><p><strong>FIFO Structure:</strong></p>
<ul>
<li>BFS uses a First-In-First-Out (FIFO) queue to maintain the order in which vertices are discovered and processed.</li>
</ul>
</li>
<li><p><strong>Visited Marking:</strong></p>
<ul>
<li>To avoid revisiting vertices, mark each vertex as visited once it is dequeued from the queue.</li>
</ul>
</li>
<li><p><strong>Shortest Path:</strong></p>
<ul>
<li>BFS guarantees that the shortest path to any reachable vertex is discovered first, making it valuable for pathfinding in unweighted graphs.</li>
</ul>
</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Shortest Pathfinding.</li>
<li>Connected Components.</li>
<li>Web Crawling.</li>
<li>Network Broadcasting.</li>
</ul>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>The time complexity of BFS is (O(V + E)), where (V) is the number of vertices and (E) is the number of edges. The algorithm visits each vertex and edge once.</li>
</ul>
<p><img src="images/breadth-first-search.png" alt="Breadth first search"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">adjacencyList</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>[]&gt;;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  }

  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">vertex: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">has</span>(vertex)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">set</span>(vertex, []);
    }
  }

  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">vertex1: <span class="hljs-built_in">string</span>, vertex2: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(vertex1)?.<span class="hljs-title function_">push</span>(vertex2);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(vertex2)?.<span class="hljs-title function_">push</span>(vertex1);
  }

  <span class="hljs-title function_">bfs</span>(<span class="hljs-params">startingVertex: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">visited</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-keyword">const</span> <span class="hljs-attr">queue</span>: <span class="hljs-built_in">string</span>[] = [];

    visited.<span class="hljs-title function_">add</span>(startingVertex);
    queue.<span class="hljs-title function_">push</span>(startingVertex);

    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> currentVertex = queue.<span class="hljs-title function_">shift</span>()!;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(currentVertex);

      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(currentVertex) || [];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) {
          visited.<span class="hljs-title function_">add</span>(neighbor);
          queue.<span class="hljs-title function_">push</span>(neighbor);
        }
      }
    }
  }
}

<span class="hljs-comment">// Example usage:</span>
<span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>();
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;A&quot;</span>);
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;B&quot;</span>);
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;C&quot;</span>);
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;D&quot;</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);

graph.<span class="hljs-title function_">bfs</span>(<span class="hljs-string">&quot;A&quot;</span>);
</code></pre><p style="page-break-after: always;"> </p><h1 id="depth-first-search">Depth-first search</h1>
<p>Depth-First Search (DFS) is a graph traversal algorithm that systematically explores the vertices of a graph by going as deep as possible along each branch before backtracking. It starts at a chosen vertex, explores as far as possible along one branch, and then backtracks to explore other branches. DFS is commonly used to detect cycles in a graph, topologically sort vertices, and solve problems related to connected components.</p>
<p><strong>How Depth-First Search Works:</strong></p>
<ol>
<li><p><strong>Start at a Vertex:</strong></p>
<ul>
<li>Begin by selecting a starting vertex and mark it as visited.</li>
</ul>
</li>
<li><p><strong>Explore Neighbors:</strong></p>
<ul>
<li>Move to an unvisited neighbor of the current vertex and repeat the process.</li>
<li>If all neighbors are visited, backtrack to the previous vertex.</li>
</ul>
</li>
<li><p><strong>Recursion or Stack:</strong></p>
<ul>
<li>DFS can be implemented using recursion or an explicit stack to keep track of the vertices to be visited.</li>
</ul>
</li>
<li><p><strong>Marking and Backtracking:</strong></p>
<ul>
<li>Mark each visited vertex to avoid revisiting and use backtracking to explore other branches.</li>
</ul>
</li>
<li><p><strong>Complete Exploration:</strong></p>
<ul>
<li>Continue the process until all reachable vertices are visited.</li>
</ul>
</li>
</ol>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><p><strong>LIFO Structure:</strong></p>
<ul>
<li>DFS often uses a Last-In-First-Out (LIFO) stack or recursion to maintain the order in which vertices are visited.</li>
</ul>
</li>
<li><p><strong>Visited Marking:</strong></p>
<ul>
<li>Mark each vertex as visited once it is reached, preventing revisiting.</li>
</ul>
</li>
<li><p><strong>Backtracking:</strong></p>
<ul>
<li>Backtrack to the previous vertex when all neighbors are explored.</li>
</ul>
</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Topological Sorting.</li>
<li>Cycle Detection.</li>
<li>Connected Components.</li>
<li>Maze Solving.</li>
</ul>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>The time complexity of DFS is (O(V + E)), where (V) is the number of vertices and (E) is the number of edges. The algorithm visits each vertex and edge once. Recursive DFS has a space complexity of (O(V)) due to the call stack, while an explicit stack implementation can have a space complexity of (O(E + V)).</li>
</ul>
<p><img src="images/depth-first-search.png" alt="Depth first search"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">adjacencyList</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>[]&gt;;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  }

  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">vertex: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">has</span>(vertex)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">set</span>(vertex, []);
    }
  }

  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">vertex1: <span class="hljs-built_in">string</span>, vertex2: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(vertex1)?.<span class="hljs-title function_">push</span>(vertex2);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(vertex2)?.<span class="hljs-title function_">push</span>(vertex1);
  }

  <span class="hljs-title function_">dfs</span>(<span class="hljs-params">startingVertex: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">visited</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">dfsHelper</span> = (<span class="hljs-params">vertex: <span class="hljs-built_in">string</span></span>) =&gt; {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vertex);
      visited.<span class="hljs-title function_">add</span>(vertex);

      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(vertex) || [];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) {
          <span class="hljs-title function_">dfsHelper</span>(neighbor);
        }
      }
    };

    <span class="hljs-title function_">dfsHelper</span>(startingVertex);
  }
}

<span class="hljs-comment">// Example usage:</span>
<span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>();
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;A&quot;</span>);
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;B&quot;</span>);
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;C&quot;</span>);
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;D&quot;</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);

graph.<span class="hljs-title function_">dfs</span>(<span class="hljs-string">&quot;A&quot;</span>);
</code></pre><p style="page-break-after: always;"> </p><h1 id="dijkstras-algorithm">Dijkstra&#39;s algorithm</h1>
<p><strong>How Dijkstra&#39;s Algorithm Works:</strong></p>
<ol>
<li><p><strong>Initialization:</strong></p>
<ul>
<li>Set the initial distance to the starting vertex as 0 and all other distances to infinity.</li>
<li>Create a priority queue or a min-heap to store vertices based on their current tentative distances.</li>
</ul>
</li>
<li><p><strong>Explore Neighbors:</strong></p>
<ul>
<li>While there are vertices in the priority queue, select the vertex with the smallest tentative distance.</li>
<li>Explore its neighbors and update their tentative distances if a shorter path is found.</li>
</ul>
</li>
<li><p><strong>Relaxation:</strong></p>
<ul>
<li>For each neighbor, calculate the sum of the tentative distance to the current vertex and the weight of the edge between them.</li>
<li>If this sum is smaller than the current tentative distance to the neighbor, update the tentative distance.</li>
</ul>
</li>
<li><p><strong>Mark as Visited:</strong></p>
<ul>
<li>Mark the current vertex as visited to avoid redundant calculations.</li>
</ul>
</li>
<li><p><strong>Repeat:</strong></p>
<ul>
<li>Repeat steps 2-4 until all vertices are visited or the destination vertex is reached.</li>
</ul>
</li>
<li><p><strong>Result:</strong></p>
<ul>
<li>The final result is an array of shortest distances from the starting vertex to all other vertices.</li>
</ul>
</li>
</ol>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><p><strong>Greedy Strategy:</strong></p>
<ul>
<li>Dijkstra&#39;s Algorithm employs a greedy strategy, always choosing the vertex with the smallest tentative distance.</li>
</ul>
</li>
<li><p><strong>Priority Queue or Min-Heap:</strong></p>
<ul>
<li>Efficient implementations use a priority queue or min-heap to efficiently retrieve the vertex with the smallest tentative distance.</li>
</ul>
</li>
<li><h2 id="non-negative-edge-weights--dijkstras-algorithm-assumes-non-negative-edge-weights-negative-weights-can-lead-to-incorrect-results"><strong>Non-Negative Edge Weights:</strong>
- Dijkstra&#39;s Algorithm assumes non-negative edge weights. Negative weights can lead to incorrect results.</h2>
<p><strong>Applications:</strong></p>
</li>
<li><p>Network Routing.</p>
</li>
<li><p>Shortest Path Problems.</p>
</li>
<li><p>Transportation and Logistics.</p>
</li>
</ul>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>The time complexity of Dijkstra&#39;s Algorithm is O((V + E) log V) using a priority queue or min-heap, where V is the number of vertices and E is the number of edges.</li>
</ul>
<p><img src="images/dijkstra.png" alt="Dijkstra algorithms"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">adjacencyList</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;&gt;;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  }

  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">vertex: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">has</span>(vertex)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">set</span>(vertex, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
    }
  }

  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">vertex1: <span class="hljs-built_in">string</span>, vertex2: <span class="hljs-built_in">string</span>, weight: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(vertex1)?.<span class="hljs-title function_">set</span>(vertex2, weight);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(vertex2)?.<span class="hljs-title function_">set</span>(vertex1, weight);
  }

  <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">startingVertex: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">distances</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> <span class="hljs-attr">previous</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> vertex <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">keys</span>()) {
      distances.<span class="hljs-title function_">set</span>(vertex, vertex === startingVertex ? <span class="hljs-number">0</span> : <span class="hljs-title class_">Infinity</span>);
      previous.<span class="hljs-title function_">set</span>(vertex, <span class="hljs-literal">null</span>);
      priorityQueue.<span class="hljs-title function_">enqueue</span>(vertex, distances.<span class="hljs-title function_">get</span>(vertex)!);
    }

    <span class="hljs-keyword">while</span> (!priorityQueue.<span class="hljs-title function_">isEmpty</span>()) {
      <span class="hljs-keyword">const</span> currentVertex = priorityQueue.<span class="hljs-title function_">dequeue</span>()!;
      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(currentVertex);

      <span class="hljs-keyword">if</span> (neighbors) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> neighbors.<span class="hljs-title function_">keys</span>()) {
          <span class="hljs-keyword">const</span> distance = distances.<span class="hljs-title function_">get</span>(currentVertex)! + neighbors.<span class="hljs-title function_">get</span>(neighbor)!;

          <span class="hljs-keyword">if</span> (distance &lt; distances.<span class="hljs-title function_">get</span>(neighbor)!) {
            distances.<span class="hljs-title function_">set</span>(neighbor, distance);
            previous.<span class="hljs-title function_">set</span>(neighbor, currentVertex);
            priorityQueue.<span class="hljs-title function_">enqueue</span>(neighbor, distance);
          }
        }
      }
    }

    <span class="hljs-keyword">return</span> { distances, previous };
  }

  <span class="hljs-title function_">shortestPath</span>(<span class="hljs-params">startingVertex: <span class="hljs-built_in">string</span>, targetVertex: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">const</span> { distances, previous } = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dijkstra</span>(startingVertex);

    <span class="hljs-keyword">const</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>[] = [];
    <span class="hljs-keyword">let</span> currentVertex = targetVertex;

    <span class="hljs-keyword">while</span> (currentVertex !== <span class="hljs-literal">null</span>) {
      path.<span class="hljs-title function_">unshift</span>(currentVertex);
      currentVertex = previous.<span class="hljs-title function_">get</span>(currentVertex)!;
    }

    <span class="hljs-keyword">return</span> { path, <span class="hljs-attr">distance</span>: distances.<span class="hljs-title function_">get</span>(targetVertex) };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">items</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>][] = [];

  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">element: <span class="hljs-built_in">string</span>, priority: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>([element, priority]);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sort</span>();
  }

  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">shift</span>();
  }

  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">sort</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);
  }
}

<span class="hljs-comment">// Example usage:</span>
<span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>();
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;A&quot;</span>);
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;B&quot;</span>);
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;C&quot;</span>);
graph.<span class="hljs-title function_">addVertex</span>(<span class="hljs-string">&quot;D&quot;</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">4</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">2</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">5</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> { path, distance } = graph.<span class="hljs-title function_">shortestPath</span>(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Shortest Path:&quot;</span>, path); <span class="hljs-comment">// Output: Shortest Path: [ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27; ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Distance:&quot;</span>, distance); <span class="hljs-comment">// Output: Distance: 4</span>

</code></pre><p style="page-break-after: always;"> </p><h1 id="floyd-warshall-algorithm">Floyd-Warshall algorithm</h1>
<p>The Floyd-Warshall Algorithm is a dynamic programming algorithm used to find the shortest paths between all pairs of vertices in a weighted graph. Unlike Dijkstra&#39;s algorithm and Bellman-Ford algorithm, Floyd-Warshall works with graphs that can have both positive and negative edge weights and can handle graphs with cycles. The algorithm iteratively updates the shortest path distances between all pairs until reaching the optimal solution.</p>
<p><strong>How Floyd-Warshall Algorithm Works:</strong></p>
<ol>
<li><p><strong>Initialization:</strong></p>
<ul>
<li>Create a matrix to represent the distances between all pairs of vertices. Initialize the matrix with the direct edge weights and set the distances to infinity where there is no direct edge.</li>
<li>Initialize the diagonal of the matrix to zeros since the distance from a vertex to itself is zero.</li>
</ul>
</li>
<li><p><strong>Iterative Updates:</strong></p>
<ul>
<li>For each vertex &#39;k&#39;, iterate through all pairs of vertices &#39;i&#39; and &#39;j&#39;.</li>
<li>Check if the path from &#39;i&#39; to &#39;j&#39; through &#39;k&#39; is shorter than the current known path from &#39;i&#39; to &#39;j&#39;.</li>
<li>If yes, update the distance from &#39;i&#39; to &#39;j&#39; with the shorter path.</li>
</ul>
</li>
<li><p><strong>Repeat:</strong></p>
<ul>
<li>Repeat the process for all vertices as intermediate vertices (&#39;k&#39;).</li>
<li>After each iteration, the matrix reflects the shortest distances between all pairs of vertices considering all possible intermediate vertices.</li>
</ul>
</li>
<li><p><strong>Result:</strong></p>
<ul>
<li>The final matrix contains the shortest distances between all pairs of vertices.</li>
</ul>
</li>
</ol>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><p><strong>Dynamic Programming:</strong></p>
<ul>
<li>Floyd-Warshall is a dynamic programming algorithm that builds solutions to subproblems to solve the overall problem.</li>
</ul>
</li>
<li><p><strong>Negative Cycles:</strong></p>
<ul>
<li>The algorithm can detect negative cycles in the graph. If there exists a negative cycle, the algorithm won&#39;t converge to a solution.</li>
</ul>
</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Network Routing.</li>
<li>Shortest Path Problems.</li>
<li>Traffic Engineering.</li>
</ul>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>The time complexity of Floyd-Warshall Algorithm is (O(V^3)), where (V) is the number of vertices in the graph.</li>
</ul>
<p><img src="images/floyd-warshall.png" alt="Floyd-Warshall algorithm"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">adjacencyMatrix</span>: <span class="hljs-built_in">number</span>[][];

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">numVertices: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span> = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: numVertices }, <span class="hljs-function">() =&gt;</span>
      <span class="hljs-title class_">Array</span>(numVertices).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Infinity</span>)
    );

    <span class="hljs-comment">// Set diagonal elements to 0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numVertices; i++) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>[i][i] = <span class="hljs-number">0</span>;
    }
  }

  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">source: <span class="hljs-built_in">number</span>, destination: <span class="hljs-built_in">number</span>, weight: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>[source][destination] = weight;
  }

  <span class="hljs-title function_">floydWarshall</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> numVertices = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>.<span class="hljs-property">length</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; numVertices; k++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numVertices; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; numVertices; j++) {
          <span class="hljs-keyword">if</span> (
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>[i][k] + <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>[k][j] &lt;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>[i][j]
          ) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>[i][j] =
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>[i][k] + <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>[k][j];
          }
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyMatrix</span>;
  }
}

<span class="hljs-comment">// Example usage:</span>
<span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>(<span class="hljs-number">4</span>);

graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);

<span class="hljs-keyword">const</span> result = graph.<span class="hljs-title function_">floydWarshall</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Shortest Path Matrix:&quot;</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> row <span class="hljs-keyword">of</span> result) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(row);
}
</code></pre><p style="page-break-after: always;"> </p><h1 id="ford-fulkerson-algorithm">Ford Fulkerson algorithm</h1>
<p>The Ford-Fulkerson Algorithm is an iterative method to compute the maximum flow in a flow network. It was initially designed to solve the max-flow min-cut problem, where the objective is to find the maximum amount of flow that can be sent from a designated source to a designated sink in a directed graph. The algorithm iteratively augments paths from the source to the sink, increasing the flow until it reaches its maximum value.</p>
<p><strong>How Ford-Fulkerson Algorithm Works:</strong></p>
<ol>
<li><p><strong>Initialization:</strong></p>
<ul>
<li>Begin with an initial flow of zero.</li>
<li>Determine the residual graph, which represents the remaining capacity for each edge.</li>
</ul>
</li>
<li><p><strong>Augmenting Paths:</strong></p>
<ul>
<li>Find an augmenting path from the source to the sink in the residual graph. An augmenting path is a path with available capacity on all its edges.</li>
</ul>
</li>
<li><p><strong>Flow Augmentation:</strong></p>
<ul>
<li>Determine the maximum flow that can be added along the augmenting path. This is the minimum capacity value of the edges on the path.</li>
</ul>
</li>
<li><p><strong>Update Residual Graph:</strong></p>
<ul>
<li>Update the residual graph by subtracting the flow added along the augmenting path and adding the reverse flow.</li>
</ul>
</li>
<li><p><strong>Repeat:</strong></p>
<ul>
<li>Repeat steps 2-4 until there are no more augmenting paths.</li>
</ul>
</li>
<li><p><strong>Result:</strong></p>
<ul>
<li>The final flow is the maximum flow in the network.</li>
</ul>
</li>
</ol>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><p><strong>Residual Graph:</strong></p>
<ul>
<li>The residual graph is crucial for the Ford-Fulkerson Algorithm. It represents the remaining capacity for each edge after the initial flow has been determined.</li>
</ul>
</li>
<li><p><strong>Augmenting Paths:</strong></p>
<ul>
<li>The algorithm focuses on finding augmenting paths, paths in the residual graph with available capacity.</li>
</ul>
</li>
<li><p><strong>Termination:</strong></p>
<ul>
<li>The algorithm terminates when no more augmenting paths can be found in the residual graph.</li>
</ul>
</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Network Flows.</li>
<li>Transportation Networks.</li>
<li>Telecommunication Networks.</li>
</ul>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>The time complexity of the Ford-Fulkerson Algorithm is not strictly defined, as it depends on the choice of augmenting paths. In the worst case, the algorithm may not terminate if the paths are not chosen carefully. When implemented with the Edmonds-Karp variant, where the shortest augmenting paths are chosen using Breadth-First Search, the time complexity is (O(VE^2)), where (V) is the number of vertices and (E) is the number of edges.</li>
</ul>
<p><img src="images/ford-fulkerson.png" alt="Ford Fulkerson algorithm"></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FordFulkerson</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">graph</span>: <span class="hljs-built_in">number</span>[][];
  <span class="hljs-keyword">private</span> <span class="hljs-attr">numVertices</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">graph: <span class="hljs-built_in">number</span>[][]</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">graph</span> = graph;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numVertices</span> = graph.<span class="hljs-property">length</span>;
  }

  <span class="hljs-title function_">fordFulkerson</span>(<span class="hljs-attr">source</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">sink</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">let</span> maxFlow = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Create a residual graph and initialize it with the original capacities.</span>
    <span class="hljs-keyword">const</span> residualGraph = <span class="hljs-variable language_">this</span>.<span class="hljs-property">graph</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> [...row]);

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">const</span> path = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bfs</span>(source, sink, residualGraph);
      <span class="hljs-keyword">if</span> (!path) {
        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// No augmenting path found, terminate the algorithm</span>
      }

      <span class="hljs-comment">// Find the minimum capacity along the augmenting path</span>
      <span class="hljs-keyword">let</span> minCapacity = <span class="hljs-title class_">Number</span>.<span class="hljs-property">POSITIVE_INFINITY</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
        <span class="hljs-keyword">const</span> u = path[i];
        <span class="hljs-keyword">const</span> v = path[i + <span class="hljs-number">1</span>];
        minCapacity = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(minCapacity, residualGraph[u][v]);
      }

      <span class="hljs-comment">// Update residual capacities and reverse edges along the path</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
        <span class="hljs-keyword">const</span> u = path[i];
        <span class="hljs-keyword">const</span> v = path[i + <span class="hljs-number">1</span>];
        residualGraph[u][v] -= minCapacity;
        residualGraph[v][u] += minCapacity;
      }

      <span class="hljs-comment">// Add the flow of the augmenting path to the total flow</span>
      maxFlow += minCapacity;
    }

    <span class="hljs-keyword">return</span> maxFlow;
  }

  <span class="hljs-title function_">bfs</span>(<span class="hljs-attr">source</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">sink</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">graph</span>: <span class="hljs-built_in">number</span>[][]): <span class="hljs-built_in">number</span>[] | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">visited</span>: <span class="hljs-built_in">boolean</span>[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">numVertices</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-attr">queue</span>: <span class="hljs-built_in">number</span>[] = [source];
    <span class="hljs-keyword">const</span> <span class="hljs-attr">parent</span>: <span class="hljs-built_in">number</span>[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">numVertices</span>).<span class="hljs-title function_">fill</span>(-<span class="hljs-number">1</span>);

    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> u = queue.<span class="hljs-title function_">shift</span>()!;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v = <span class="hljs-number">0</span>; v &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">numVertices</span>; v++) {
        <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; graph[u][v] &gt; <span class="hljs-number">0</span>) {
          queue.<span class="hljs-title function_">push</span>(v);
          parent[v] = u;
          visited[v] = <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-keyword">if</span> (!visited[sink]) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// No augmenting path found</span>
    }

    <span class="hljs-keyword">const</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">number</span>[] = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v = sink; v !== source; v = parent[v]) {
      path.<span class="hljs-title function_">unshift</span>(v);
    }
    path.<span class="hljs-title function_">unshift</span>(source);

    <span class="hljs-keyword">return</span> path;
  }
}

<span class="hljs-comment">// Example usage:</span>
<span class="hljs-keyword">const</span> graph = [
  [<span class="hljs-number">0</span>, <span class="hljs-number">16</span>, <span class="hljs-number">13</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
];

<span class="hljs-keyword">const</span> fordFulkerson = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FordFulkerson</span>(graph);
<span class="hljs-keyword">const</span> maxFlow = fordFulkerson.<span class="hljs-title function_">fordFulkerson</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Maximum Flow:&quot;</span>, maxFlow);
</code></pre><p style="page-break-after: always;"> </p>