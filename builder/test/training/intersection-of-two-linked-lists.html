<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Holy Theory</title><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script><style>body {
    margin: 0;
    padding: 0;
}

img {
    max-width: 400px;
}

.main {
    max-width: 800px;
    margin: 0 auto;
}
.navigation {
    display: flex;
    flex-direction: row;
    border: 1px solid #000;
}

.navigation ul {
    display: flex;
    padding: 0;
    flex-direction: row;
    margin: 0;
}

.navigation ul li {
    display: flex;
    list-style: none;
    padding: 10px;
}</style></head><body><div class="main"><span><nav class="navigation"><ul><li> <a href="/holy-theory/builder/test/">Main page</a></li><li> <a href="/holy-theory/builder/test//languages.html">Statistics</a></li></ul></nav></span><h1></h1><span><h1 id="intersection-of-two-linked-lists">Intersection of Two Linked Lists</h1>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">headA: ListNode | <span class="hljs-literal">null</span>, headB: ListNode | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">let</span> pointer1 = headA;
    <span class="hljs-keyword">let</span> pointer2 = headB;

    <span class="hljs-keyword">while</span>(pointer1 !== pointer2) {
        pointer1 = pointer1 === <span class="hljs-literal">null</span> ? <span class="hljs-attr">headB</span>: pointer1.<span class="hljs-property">next</span>;
        pointer2 = pointer2 === <span class="hljs-literal">null</span> ? <span class="hljs-attr">headA</span>: pointer2.<span class="hljs-property">next</span>;
        
    }
    <span class="hljs-keyword">return</span> pointer1;
};
</code></pre><p>The code is a TypeScript function that finds the intersection node of two singly-linked lists <code>headA</code> and <code>headB</code>. The intersection node is the node at which the two linked lists meet if they share a common portion.</p>
<p>Here&#39;s a step-by-step explanation of the code:</p>
<ol>
<li><p>The function <code>getIntersectionNode</code> takes two parameters: <code>headA</code> and <code>headB</code>, which are the heads of the two linked lists.</p>
</li>
<li><p>Two pointers <code>pointer1</code> and <code>pointer2</code> are initialized to point to the heads of <code>headA</code> and <code>headB</code>, respectively.</p>
</li>
<li><p>A while loop is used to traverse the linked lists. The loop continues as long as <code>pointer1</code> is not equal to <code>pointer2</code>, which means they haven&#39;t met at the intersection node.</p>
</li>
<li><p>Inside the loop:</p>
<ul>
<li>The <code>pointer1</code> is moved to the next node (<code>pointer1.next</code>), or if it has reached the end of list A (<code>pointer1</code> is <code>null</code>), it is moved to the head of list B (<code>headB</code>).</li>
<li>Similarly, the <code>pointer2</code> is moved to the next node (<code>pointer2.next</code>), or if it has reached the end of list B (<code>pointer2</code> is <code>null</code>), it is moved to the head of list A (<code>headA</code>).</li>
</ul>
</li>
<li><p>The loop continues until <code>pointer1</code> and <code>pointer2</code> point to the same node, which is the intersection node.</p>
</li>
<li><p>Once the intersection node is found, the function returns <code>pointer1</code> (or <code>pointer2</code>, as they are both pointing to the intersection node).</p>
</li>
<li><p>If there is no intersection between the linked lists, both <code>pointer1</code> and <code>pointer2</code> will eventually become <code>null</code>, and the loop will exit.</p>
</li>
</ol>
<p>Techniques used in this code include:</p>
<ul>
<li>Using two pointers (<code>pointer1</code> and <code>pointer2</code>) to traverse the linked lists simultaneously.</li>
<li>Utilizing the property of linked lists to move one pointer to the head of the other list when it reaches the end, effectively accounting for the difference in lengths between the lists.</li>
<li>Detecting the intersection point by checking if <code>pointer1</code> and <code>pointer2</code> are equal.</li>
<li>Returning the intersection node once it is found.</li>
</ul>
<p>Overall, this algorithm finds the intersection node of two linked lists with a time complexity of O(m + n), where m and n are the lengths of the two linked lists.</p>
</span></div></body></html>