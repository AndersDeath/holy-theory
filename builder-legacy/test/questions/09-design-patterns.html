<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Holy Theory</title><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script><style>body {
    margin: 0;
    padding: 0;
}

img {
    max-width: 400px;
}

.main {
    max-width: 800px;
    margin: 0 auto;
}
.navigation {
    display: flex;
    flex-direction: row;
    border: 1px solid #000;
}

.navigation ul {
    display: flex;
    padding: 0;
    flex-direction: row;
    margin: 0;
}

.navigation ul li {
    display: flex;
    list-style: none;
    padding: 10px;
}</style></head><body><div class="main"><span><nav class="navigation"><ul><li> <a href="/holy-theory/builder/test/">Main page</a></li><li> <a href="/holy-theory/builder/test//languages.html">Statistics</a></li></ul></nav></span><h1></h1><span><h1 id="design-patterns">Design patterns</h1>
<p><strong>Creational Patterns:</strong></p>
<ol>
<li><p><strong>Factory Method:</strong> Creates objects without specifying the exact class by delegating the instantiation to subclasses. Provides a way to create objects based on certain conditions or parameters.</p>
</li>
<li><p><strong>Abstract Factory:</strong> Provides an interface for creating families of related or dependent objects without specifying their concrete classes. Supports creating objects with different implementations but having a common theme.</p>
</li>
<li><p><strong>Builder:</strong> Separates the construction of a complex object from its representation, allowing the same construction process to create different representations. Useful when there are multiple ways to construct an object.</p>
</li>
<li><p><strong>Prototype:</strong> Clones existing objects to create new ones, avoiding the need for subclassing. Allows objects to be copied without making the code dependent on their classes.</p>
</li>
<li><p><strong>Singleton:</strong> Ensures a class has only one instance and provides a global point of access to it. Useful when you need to have a single shared instance across the entire application.</p>
</li>
</ol>
<p><strong>Structural Patterns:</strong>
6. <strong>Adapter:</strong> Converts the interface of one class into another interface that clients expect, making incompatible classes work together.</p>
<ol start="7">
<li><p><strong>Bridge:</strong> Decouples an abstraction from its implementation, allowing them to vary independently. Useful when you want to extend a class in two independent dimensions.</p>
</li>
<li><p><strong>Composite:</strong> Treats individual objects and compositions of objects uniformly, allowing you to create complex tree-like structures.</p>
</li>
<li><p><strong>Decorator:</strong> Dynamically adds behavior or responsibilities to objects without altering their code directly. Offers a flexible alternative to subclassing.</p>
</li>
<li><p><strong>Facade:</strong> Provides a simplified interface to a complex subsystem, making it easier to use and understand.</p>
</li>
<li><p><strong>Flyweight:</strong> Shares data between multiple objects to reduce memory usage when many similar objects exist.</p>
</li>
<li><p><strong>Proxy:</strong> Acts as a placeholder for another object, controlling access to it, and providing additional functionality when required.</p>
</li>
</ol>
<p><strong>Behavioral Patterns:</strong>
13. <strong>Chain of Responsibility:</strong> Allows multiple objects to handle a request without specifying the receiver explicitly. The request is passed along the chain until it&#39;s handled.</p>
<ol start="14">
<li><p><strong>Command:</strong> Encapsulates a request as an object, allowing parameterization of clients with different requests, queuing of requests, or logging of the requests.</p>
</li>
<li><p><strong>Iterator:</strong> Provides a way to access elements of a collection without exposing its underlying representation.</p>
</li>
<li><p><strong>Mediator:</strong> Defines an object that centralizes communication between multiple objects, reducing their direct interactions.</p>
</li>
<li><p><strong>Memento:</strong> Captures and externalizes an object&#39;s internal state, allowing the object to be restored to that state later.</p>
</li>
<li><p><strong>Observer:</strong> Allows an object to publish changes to its state, notifying dependent objects to update automatically.</p>
</li>
<li><p><strong>State:</strong> Allows an object to change its behavior when its internal state changes.</p>
</li>
<li><p><strong>Strategy:</strong> Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Enables selecting an algorithm at runtime.</p>
</li>
<li><p><strong>Template Method:</strong> Defines the skeleton of an algorithm in a method, allowing subclasses to provide specific implementations of some steps.</p>
</li>
<li><p><strong>Visitor:</strong> Separates algorithms from the objects on which they operate, enabling adding new operations without modifying the objects&#39; classes.</p>
</li>
</ol>
</span></div></body></html>